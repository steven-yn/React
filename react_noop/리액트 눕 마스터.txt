리액트 기초 익히기
(react_noop)

이벤트는 어떠한 사건이 일어났을때를 말함.
이벤트 핸들러는 카멜표기법

onClick = {함수}

이벤트 핸들러는 문자열을 전달하지않고 함수를 전달한다 !
함수를 넣지 않게되면 이벤트 핸들러가 작동하지 않음.

함수는 const name = () => {
	함수 내용
};

이벤트 핸들러나 state가 논리적 오류가 없음을 확인할떄는 console.log를 사용하자.
event 객체의 사용.

4강 리액트 훅스 useState

변수의 사용은 {변수} (일반텍스트가 들어갈 자리의경우)

const [변수이름, set변수이름] = useState();

useState("초기값");

form은 onSubmit 하면 페이지가 리프레시 되도록 설계 되어있음.
event 객체를 받아서 preventDefault 하면 리프레시 되지않고 값을 저장.

5강 리액트 훅스 useEffect

어떤 일을 실행시킬때 컴포넌트가 리렌더링이 될때마다 실행할수 있게됨.

state가 여러개일때 원하는 하나의 state 에만 useEffect가 반응하도록 하고 싶다면
어레이에 [목표state] 를 넣어주면 된다.

첫렌더링때만 실행시키고, 그이후에 실행 하지 않도록 하는방법

6강 컴포넌트로 반복제거

어떠한 이유로 클릭 카운터를 여러개 쓰고싶을떄 어떻게 해야할까?

컴포넌트를 모듈처럼 이용해서 해당 모듈을 수정하면 같은 기능을 한번에 업데이트하기가 쉽다.

7강 props

컴포넌트를 import 해서 불러와 사용하는 자 <== 부모컴포넌트
사용 되어지는 자 <== 자식컴포넌트

부모컴포넌트가 자식컴포넌트에 데이터를 보내고싶다? props 사용.

props 에 보내지는 데이터는 key(네임) 와 value(값)

props로 state도 보낼수 있다.

8강 리액트 반복문 ( JS의 map 펑션 )

반복되면서 변화가 있는 앱을 코딩해야할때, JS의 map 함수를 이용하여 짤수있다.

어레이.map() : 어레이에 있는 아이템들을 마음대로 형식을 바꿀수가 있다.

어레이를 맵에 담아서 변수에 대입하고, JSX형식으로 return 함.

map(사용할 변수 이름 => {
	return (
	
	)
});

실사용 할때, div 에서 사용할 맵에 해당하는 key를 선언해줘야함.
데이터베이스에서 가져오게되면, ID값이 가장 유니크하니까 아이디값으로 key를 설정해주고,

이 key는 어레이가 추가되거나 업데이트, 삭제될때 리액트가 어떤 아이템인지 식별할때 도움을줌.

10 컴포넌트와 props 데이터 보내기 복습

어레이 데이터를 props 를 이용해 보내고,
데이터 불러오는 과정을 외부 컴포넌트로 만들어 import 해옴.

movie를 props로 등록하지 않았기 때문에? 

무비라는 이름으로 무비컴포넌트에 무비라는 데이터를 오브젝트를 어레이 상태로 보내줍니다
비구조 할당으로 변환해서 받아오는 오브젝트를 쓰고 (movie)
props는 지워줌.

map에 따라오는 key는 사용하는 외부 컴포넌트에 달아줌.

11 영화 리스트에 추가 폼 만들기 1

state가 아닌 요소(어레이 등)에 업데이트하면 리렌더링이 이루어지지 않음.
어레이를 state로 변경

useState 사용할때 setMovies 로 업데이트 시키면
스테이트 안의 어레이 내용을 덮어버리게 됨.
따라서 기존의 내용을 유지하고 하나를 추가 하고싶다? 하면
새로운 배열을 넣어주고 ...movies 처럼 해준다음
어레이의 데이터 포맷과 같은 형식으로 써줌.

...movies 를 구조분해 할당 이라고함. ( 비구조화 할당 과 같은듯 ) destructure 

const p = ['a', 'b'];
const q = [p[0], p[1], 'c'];
const w = [...q, 'd'];
w
(4) ['a', 'b', 'c', 'd']

12 자식이 부모 컴포넌트 변경

지난번 적용한 폼을 외부컴포넌트로 빼내는 작업해보기.

외부 컴포넌트로 props를 통해 보내줌.

JS의 filter를 이용.

14 영화 폼 validation

-1. 영화 추가 버튼을 누르면, onSubmit 함수가 실행
-2. onSubmit 에서 props로 받아온 addMovie가 실행되면서
-3. addMovie 에서 setMovies를 실행 시켜서 타이핑한 텍스트가 입력이 된다.

추가 하기전에 movieTitle 과 movieYear가 값이 비어있는지
빈값이면 에러를 보여주고 빈값이 아니면 영화를 추가하는 코드작성.

15 Input과 Field 외부 컴포넌트로 뺴내기 & fragment

input과 에러메시지 외부컴포넌트로 뺴는작업.

변경할수 있는 부분을 props로 받음.

props 보낼떄 변수, 함수는 {}로 감싸서
스트링은 그대로 ""

외부컴포넌트로 빼내게 되더라도 코딩길이는 비슷하나
재사용이 가능하고 css를 바꾸게 되면 inputfield 하나만 변경해주면
여러개의 input 모두 바꿔주기가 쉬움.

16 React router 설치하기

페이지를 여러개 만드는 방법 !
bootstrap cdn 링크 긁어서 index.html 넣기
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
리액트에서 여러 페이지를 가질수 있게 해주는것 : react router

web용은 말그대로 web용
native는 react native를 사용한 모바일 어플리케이션 용

17 네비게이션 바 만들기.

부트스트랩 이용해서 만들기.
getbootstrab.com 에서 navbar 복사해서 외부 컴포넌트로 작성.
그후 App.js 에서 import

18 react router 실적용

Route 태그 하나당 페이지 하나.

19 react router 작동원리

리액트는 싱글 페이지 어플리케이션 이지만 여러개의 페이지를 구현할수 있는 이유?

index.html 의 div id는 root 이고,
index.js 에서 App.js 컴포넌트를 불러와 root 안에 넣어준다.

class네임이 App 인 컴포넌트를 div안에 통채로 넣어줌.

navbar 내부에서는 Link 태그를 이용하지만 최종적으로는 a 태그로 변환된다.

싱글 페이지 어플리케이션의 경우에는 초기 로딩이 느리다.
다른 페이지 정보가 들어있는 ( 컴포넌트등 ) 파일들이 하나의 js로 변환되어서 입력받게되기 때문.
나중에 코드스플릿 이라는 기능을 이용해서 js를 따로따로 쪼개서 받아올수 있다.
멀티 페이지 어플리케이션 에 비하면 초기페이지 로딩속도가 느리다.

a 태그로 작성되어있는 다른 페이지들은 서버로 요청될때
리액트 라우터가 그 요청을 가로챈다. js 안에 무비 페이지를 이용해서
home 부분을 싹 빼주고, 스위치 안에 무비스 컨텐츠를 넣어주게됨.
다시말해, 컨텐츠만 바뀌게 되는것이다.
navbar의 내용은 바뀌지 않고 컨텐츠만 변경됨.

20 NavLink 사용하기.

선택한 페이지 탭의 스타일 변경.

NavLink는 네비게이션용 링크

<NavLink to="/faq" activeClassName="원하는 클래스의 이름">

해당 페이지가 액티브일때 해당 클래스로 들어가게됨.

현재 어느 페이지를 보고있는가 가시화

21 유저 데이터 받아오기

json placeholder API를 사용하여 가짜 데이터를 받아온다.

npm 패키지 중 axios 를 사용.
fetch는 지원이 되지 않는 브라우저가 많다.
axios는 다양한 브라우저모두 지원이 된다. 유용한 여러 기능이 많다.
회사에서 실무할때도 많이사용

users 페이지를 추가하기전 각각의 Route들을 컴포넌트로 빼내보자.
fetch는 비동기여서 response.json 을 써줘야하지만
axios는 자동으로 한번 해준다. 따라서 다음내용 붙여씀.
맨마지막에 []를 써줘서 useEffect가 처음 한번만 데이터 가져오도록 함.

22 유저 데이터 화면에 출력하기

axios로 받은 유저 데이터(response)를 state에 담아 화면에 출력하기.
초기값을 [] 로 시작해서 데이터를 채워넣음.
유저 스테이트가 업데이트가 되면서 유저 리스트가 스테이트 어레이에 채워지게되고,
실행시킨 UserList 컴포넌트가 렌더링됨.
props로 받고 map()을 통해서 user.name을 div로 리턴하게됨.
map에는 키가 따라옴. 맵 내부 변수의 이름은 마음대로.

23 유저 데이터 화면에 출력 2

위에서 만든 유저페이지를 부트스트랩을 이용해 좀더 꾸미기

24 로딩 Spinner 추가하기

유저 데이터를 받아와서 그 리스트를 렌더링 하기까지 시간이 걸리게된다.
초기값이 빈 배열이기 때문에 처음에 아무것도 보이지 않게됩니다.

25 routes 파일 만들기
App.js 파일에 라우트 정보가 길어지므로 이를 다른 파일로 만듦

26 유저 페이지 라우트 추가
유저 페이지에서 유저 한명의 라우트를 추가
url 상에서 ....users/1 과 같이 끝자리 id를 캐치해와야하는데
이때 사용할만한 것이 useParams
url 파라미터를 받아옴.

라우츠 컴포넌트에서 /:id로 선언 해줫기 때문에 id만 캐치함.

27 유저를 클릭하면 유저 디테일 페이지로 이동하도록

UserList를 받아오는 컴포넌트에서 user.name 데이터를 link 태그로 감싼다.

Link 속성 내의 to 속성에서 `(백틱) 으로 감싸고 $ 선택자 사용해서 변수를 활용.