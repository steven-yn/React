
21장 백엔드 폴더 + blog/blog-backend 폴더 압축해서 내 컴퓨터에 적용시키기
패키지1개 프로그램1개 설치해야됨.

21.5.5 posts 라우트 생성 
이번엔 api 라우트 내부에 posts 라우트를 만들자. api 디렉터리에 posts 디렉터리를 만들고,
그 내부에 index.js 파일 만들기.

posts 라우트에 여러 종류의 라우트를 설정한 후 
모두 printInfo 함수를 호출하도록 설정.
문자열이 아닌 JSON 객체를 반환하도록 설정하고, 
이 객체에는 현재 요청의 메서드, 경로, 파라미터를 담았다.

코드 완성후 api 라우트에 posts 연결.
연결하는 방법은 서버의 메인 파일에 api 라우트 적용방법과 비슷.

기존 test 라우트는 지우고, posts 라우트를 불러와 설정.
localhost:4000 으로 브라우저 실행.

/api/posts/ 경로로 GET 메서드 가 실행된다.
이제 나머지 API 테스트 해보자.
GET 메서드를 사용하는 API 는 웹 브라우저에서 주소를 입력하여
테스트 할수 있지만, POST, DELETE 등 다른 메서드를 사용하면 JS로 호출.

우리가 만든 API 를 JS로 호출하는 대신, 편의상 REST API 요청 테스트를
쉽게 할수 있는 Postman 이라는 프로그램을 설치해서 사용.

21.5.5.1 Postman 의 설치 및 사용 
Postman 은 모든 운영체제를 지원하는 프로그램.
공식사이트 www.getpostman.com 에서 인스톨러로 설치. (get started)

GET 셀렉트 박스를 클릭하여 메서드를 선택후 오른쪽 텍스트 박스에
주소를 입력하고 Send 버튼을 누르면 요청.

POST /api/posts 로 요청시 프로그램에 JSON 객체가 반환되는것을 확인.
다른 API 도 입력 해보자. 경로 끝에 /10 을 붙임.

21.5.5.2 컨트롤러 파일 작성 
라우트를 작성하는 과정에서 특정 경로에 미들웨어 등록시 다음과 같이
두번째 인자에 함수를 선언해서 바로 넣어줄수 있다. 
router.get('/', ctx => {});

하지만 각 라우트 처리함수의 코드가 길면 라우터 설정을 한눈에 보기 힘들다.
그렇기 때문에 이 라우트 처리 함수들을 다른 파일로 따로 분리해서 관리.
이 라우트 처리함수만 모아 놓은 파일을 컨트롤러 라고함.

지금은 DB 에 연결하지 않았으므로 JS 배열기능만 사용하여 임시로 구현.

API 기능을 본격적으로 구현하기전 먼저 koa-bodyparser 미들웨어 적용.
이 미들웨어는 POST/PUT/PATCH 같은 메서드의 Request Body에
JSON 형식으로 데이터를 넣어주면, 이를 파싱하여 서버에서 사용 할수 있게함.

패키지 설치 
yarn add koa-bodyparser

bodyparser 적용하기.
주의 사항 : router 를 적용하는 코드의 윗부분에서 적용.

posts/posts.ctrl.js 에 파일작성

컨트롤러를 만들면서 exports.이름 = ... 형식으로 함수를 내보내 주었다.
이렇게 내보낸 코드는 다음형식으로 불러올 수 있다.

const 모듈이름 = require('파일이름');
모듈이름.이름();

const postsCtrl = require('./posts.ctrl');
posts.get('/', postsCtrl.list);

require('./posts.ctrl') 을 입력해 방금만든 posts.ctrl.js 파일 
불러온다면 이러한 객체를 불러오게 된다.
{
	write: Function,
	list: Function,
	read: Function,
	remove: Function,
	replace: Function,
	update: Function,
};

우리가 만든 컨트롤러 함수들을 한번 각 라우트에 연결시켜 보자.

list, read, remove 를 제외한 API 들은 요청할때 Request Body 가 필요.
Postman 에서 이 값을 어떻게 넣는지 알아보자.

Postman 에서 POST 를 선택하면 다음과 같이 Body 부분이 활성화.
Body 탭을 선택하고 raw 옵션을 클릭한 후 주황색으로 나타나는 데이터 타입을
JSON 으로 설정.

그후 하단 텍스트 박스에 이러한 JSON 을 입력시킴.

{
	"title": "테스팅",
	"body": "테스팅"
}

모두 입력한뒤 Send 버튼을 눌러서 POST 요청.
POST 가 성공적으로 등록됬는지 GET 으로 요청해보기.

[
    {
        "id": 1,
        "title": "제목",
	    "body": "내용"
    },
    {
        "id": 2,
        "title": "테스팅",
	    "body": "테스팅"
    }
]

등록에 성공시 등록한 POST 가 list 함수로 조회된다.

우리가 구현한 update 와 replace 함수는 용도는 비슷하지만 구현방식이 다르다.
update(PATCH) 는 기존값 유지 하면서 새값을 덮어 씌우고,
replace(PUT) 은 Request Body 로 받은 값이 id를 제외한 모든값 대체.

patch
{
    "title": "변경됨"
}

put
{
    "title": "변경됨"
}

결과 비교 해보기.
PUT 사용시 기존 body 가 사라져 버림.
따라서 포스트 수정 API 를 PUT 으로 구현해야 할땐
모든 필드가 다있는지 검증하는 작업 필요.

21.6 정리 

이 장에서는 Koa 를 사용해 백엔드 서버를 만드는 기본 개념에 대해 알아봤다.
먼저 REST API 를 살펴본 후 어떻게 작동하는지를 JS 배열을 사용하여 
구현하면서 알아보았다. JS 배열을 사용해 구현하면 서버를 재시작 할때 
당연히 데이터가 소멸된다.
이 데이터를 로컬 파일에 저장하는 방법도 있지만, 실제 프로젝트는 권장 X
그대신 MySQL, MongoDB 등의 데이터베이스에 정보를 저장하여 관리.

데이터베이스 를 사용하면 다양하고 효율적인 방식으로 많은양의 데이터를 
읽고 쓸수가 있다. 이책에선 MongoDB 를 사용하여 백엔드 구현.

22장 mongoose 를 이용한 MongoDB 연동 실습.

이 장에선 우리가 만들 Node.js 서버와 MongoDB 를 연동할수 있도록 
MongoDB 기초 지식을 알아본다. 그리고 mongoose 를 이용해서 
서버에서 직접 데이를 추가,조회,삭제,수정 하는 방법도 알아본다.

실습 진행 순서 
-1) MongoDB 기본 지식 알아보기
-2) 작업환경 설정하기 
-3) mongoose 로 데이터베이스 연결하기 
-4) esm 으로 ES 모듈 import/export 문법 사용하기 
-5) 스키마와 모델 이해하기
-6) REST API 구현하기 
-7) 페이지네이션 구현하기 

22.1 소개하기 

서버를 개발할때 DB 를 사용하면 웹 서비스에서 사용되는 데이터를 저장하고,
효율적으로 조회하거나 수정할수 있다. 기존에는 MySQL, OracleDB, PostgreSQL 같은 
RDBMS (관계형 DB) 를 자주 사용.

그런데 관계형 DB 에는 몇가지 한계가 있다.

1 데이터 스키마가 고정적임.
==> 스키마란 DB 에 어떤 형식의 데이터를 넣을지에 대한 정보를 가리킨다.
예를 들어 회원정보 스키마 라면 계정명, 이메일, 이름 등이 된다.
새로 등록하는 데이터 형식이 기존에 있던 데이터들과 다르다면?
기존 데이터를 모두 수정해야 새 데이터를 등록할 수 있다.
그래서 데이터양이 많을땐 DB 의 스키마를 변경하는 작업이 매우 번거롭다.

2 확장성.
RDBMS 는 저장하고 처리해야 할 데이터양이 늘어나면 여러 컴퓨터에 분산시키는 것이 아닌,
해당 DB 서버의 성능을 업그레이드 하는 방식으로 확장 해줘야 했다.

MongoDB 는 이런 한계를 극복한 문서 지향적 NoSQL 데이터 베이스 다.
이 DB 에 등록하는 데이터들은 유동적인 스키마를 지닐수 있다.
종류가 같은 데이터라고 하더라도, 새로 등록할 데이터 형식이 바뀐다 하더라도
기존 데이터까지 수정할 필요는 없다.
서버의 데이터 양이 늘어나도 한 컴퓨터에서만 처리하는 것이 아닌 여러 컴퓨터로 분산하여
처리할수 있도록 확장하기 쉽게 설계 되어있다.

이 책에서는 MongoDB 를 사용해 서버를 개발한다.
MongoDB 가 무조건 기존의 RDBMS 보다 좋은것은 아니다.
상황별로 적합한 DB가 다를수 있다.
예를 들어 데이터의 구조가 자주 바뀐다면 MongoDB 가 유리.
그러나 까다로운 조건으로 데이터를 필터링 해야하거나, ACID 특성을 지켜야 하면
RDBMS 가 더유리할수 있다.

ACID 특성은 원자성(Atomicity) 일관성 (Consistency) 고립성 (Isolation)
지속성 (Durability) 의 앞 글자를 따서 만든 용어로, DB 트랜잭션이
안전하게 처리되는 것을 보장하기 위한 성질을 의미.

이 책에서 구현할 서버는 RDBMS 로 만들수도 있고, MongoDB 로 만들수도 있다.
MongoDB 를 사용한 이유는 무엇보다 조금만 배워도 유용하게 활용 가능하기 때문.
RDBMS 는 설정할것도 많고, 배워야 할것도 많다.
만약 서버 개발에 관심이 있다면 나중에 RDBMS 도 꼭 한번 사용을 권장.

22.1.1 문서란?
여기서 '문서' 는 RDBMS 의 '레코드' 와 개념이 비슷함.
문서의 데이터 구조는 한개 이상의 키-값 쌍으로 되어있다.

MongoDB 에서 사용하는 문서 예시를 살펴보자.
{
	"_id": ObjectId ("45640654064"),
	"username": "steven"
	"name": { first: "M.J", last: "Kim" }
}

문서는 BSON ( 바이너리 형태 JSON ) 으로 저장.
그렇기 때문에 나중에 JSON 형태의 객체를 DB 에 저장할때,
큰 공수를 들이지 않고도 데이터를 DB에 등록할수 있어 매우 편하다.

새로운 문서를 만들면 _id 라는 고유값을 자동으로 생성하는데, 이 값은
시간, 머신 아이디, 프로세스 아이디, 순차 번호로 되어있어 값의 고유함을 보장.

여러 문서가 들어있는 곳을 컬렉션 이라고 함.
기존 RDBMS 에서는 테이블 개념을 사용하므로 각 테이블마다 같은 스키마를
가지고 있어야 한다.
새로 등록해야 할 데이터가 다른 스키마를 가지고 있다면,
기존 데이터들의 스키마도 모두 바꿔줘야 한다.
반면 MongoDB 는 다른 스키마를 가지고있는 문서들이 한 컬렉션 에서 공존 가능.

레코드 - 문서
키 - _id ( 시간, 머신 아이디, 프로세스 아이디, 순차 번호로 되어있어 값의 고유함을 보장. )
값 - 아무 데이터 
테이블 - 컬렉션

처음에는 데이터에 전화번호가 필요 없었는데, 나중에 필요해졌다고 가정.
RDBMS 에서는 한 테이블의 모든 데이터가 같은 스키마를 가져야 하기 때문에,
기존 데이터 전체를 일일이 수정해야 한다.
하지만 MongoDB 에서는 컬렉션 안의 데이터가 같은 스키마를 가질 필요가 없어서
그냥 넣기만 하면 된다. ( 개꿀 )

22.1.2 MongoDB 구조 

MongoDB 구조는 서버 하나에 DB 여러개를 가질수 있다.
각 DB 에는 여러개의 컬렉션이 있으며, 컬렉션 내부에는 문서들이 있다.

22.1.3 스키마 디자인 
MongoDB 에서 스키마를 디자인 하는 방식은 기존 RDBMS 에서 디자인 하는 방식과
완전히 다르다. RDBMS 에서 블로그용 데이터 스키마를 설계 한다면
각 포스트, 댓글마다 테이블을 만들어 필요에 따라 JOIN 해서 사용하는것이 일반적.

하지만 NoSQL 이라면?
{
	_id: ObjectId,
	title: String,
	body: String,
	username: String,
	createdDate: Date,
	comments: [
		{
			_id: ObjectId,
			text: String,
			createdDate,
		},
	],
};

이런 상황에서 보통 MongoDB 는 댓글을 포스트 문서 내부에 넣는다.
문서 내부에 또다른 문서가 위치할수 있는데, 이를 서브다큐먼트 라고 함.
서브다큐먼트 또한 일반 문서를 다루는것 처럼 쿼리할수 있다.

문서 하나에는 최대 16MB 만큼 데이터를 넣을수 있다.
100자 댓글 데이터라면 대략 0.24KB
16MB 는 16,384KB 이므로 댓글 데이터를 약 68,000 개 넣을수 있다.

서브다큐먼트 에서 이 용량을 초과할 가능성이 있다면 컬렉션을 분리시킴.

22.2 MongoDB 서버 준비 

22.2.1 설치 
MongoDB 서버를 사용하려면 우선 설치.
MongoDB 공식 사이트 다운로드 페이지 에서 인스톨.

설치가 완료되면 자동으로 MongoDB 서버가 Windows 서비스로 등록되어 시작.
설치 과정에서 MongoDB Compass 라는 프로그램도 함께 설치된다.
이 프로그램은 DB 를 GUI 로 확인할수 있다.
이 프로그램에 대해서는 잠시후 알아보자.

22.2.2 MongoDB 작동 확인 
MongoDB 가 성공적으로 설치되고 제대로 가동중인지 확인하려면, 터미널에서 mongo 를 입력.

22.3 mongoose 의 설치 및 적용 
mongoose 는 Node.js 환경에서 사용하는 MongoDB 기반 ODM 라이브러리.
이 라이브러리는 DB 문서들을 JS 객체처럼 사용할수 있게 해줌.

백엔드 프로젝트에 이어서 진행.

dotenv 는 환경변수 들을 파일에 넣고 사용할 수 있게 하는 개발도구.
mongoose 를 사용해 MongoDB 에 접속할때, 서버에 주소나 계정 및 비밀번호가
필요할수도 있다. 이렇게 민감하거나 환경별로 달라질수 있는 값은
코드안에 직접 작성하지 않고, 환경변수로 설정하는것이 좋다.
프로젝트를 깃허브, 깃랩 등의 서비스에 올릴때는 .gitignore 를 작성해서 
환경변수가 들어있는 파일들은 제외 시켜야한다.

22.3.1 .env 환경변수 파일 생성.
환경변수 에는 서버에서 사용할 포트와 MongoDB 주소를 넣는다.
프로젝트 의 루트 경로에 .env 파일을 만들고 내용입력.

PORT=4000
MONGO_URI=mongodb://localhost:27017/blog

여기서 blog 는 우리가 사용할 DB이름.
지정한 DB가 서버에 없다면 자동으로 만들어 주므로 사전에 직접 생성할 필요가 없다.

다음으로 src/index.js 파일의 맨 위에 다음과 같이 dotenv 를 불러와서 
config() 함수를 호출. Node.js 에서 환경변수는 process.env 값을 통해 조회.

22.3.2 mongoose 로 서버와 DB 연결.
이제 mongoose 를 이용해 서버와 DB 연결.
연결할땐 mongoose 의 connect 함수 사용.

connect 에 두번째 파라미터 안넣음.

22.4 esm 으로 ES 모듈 import/export 문법 사용하기 

기존 리액트 프로젝트에서 사용해 오던 ES 모듈 import/export 문법은
Node.js 에서 아직 정식으로 지원하지 않는다.
Node.js 에 해당 기능이 구현되어있긴 하지만, 아직 실험적인 단계이기 때문에 
기본 옵션으론 사용할수 없으며, 확장자를 .mjs 로 사용하고 node를 실행할때
--experimental-modules 라는 옵션을 넣어줘야 함.

Node.js 에서 import/export 문법을 꼭 사용할 필요는 없지만,
이 문법을 사용하면 VS Code 에서 에밋을 통해 모듈을 자동으로 쉽게
불러올수도 있고 코드도 더욱 깔끔해진다.
그래서 우리는 esm 이라는 라이브러리의 도움을 받아 해당 문법을 사용해 보자.

esm 설치 

yarn add esm

기존 src/index 를 main.js 로 바꾸고 새로 index.js 를 만들어서 
esm 을 불러오는 코드를 작성.
그리고 package.json 에 scripts 부분을 수정해줌.
eslint 에서 import/export 구문 사용해도 오류 간주하지 않도록
.eslint.json 에서 수정.

이렇게 하면 프로젝트 에서 import/export 구문을 자유롭게 사용가능.
그리고 이전에 만들었던 모듈을 하나하나 수정해 준다.
기존에 실행 중이던 서버는 종료하고,
yarn start:dev 명령어를 입력하여 서버 구동.

22.4.1 기존 코드 ES Module 형태로 바꾸기.

api/posts/posts.ctrl.js 파일에 exports 를 export const 로 모두변경.

다음으로 src/api/posts/index.js 수정
여기에서 코드 저장시 오류가 뜨지만, 다음 두개를 더 수정하면 해결.

src/api/index.js 
src/main.js 까지 모두 수정후,
Postman 으로 4000/api/posts 로 요청을 보내보기.
작동 확인이 된다면, 마지막으로 프로젝트 루트 디렉터리에 jsconfig.json 작성.
src 보다 하나 위로 올라가야함.

이 파일을 작성해 주면 나중에 자동완성을 통해 모듈을 불러올 수 있다.
src 디렉터리에 sample.js 라는 파일을 작성하고,
api 를 입력했을때 자동완성 할수 있는 인텔리센스 창이 뜨는지 확인.

22.5 DB 의 스키마와 모델

mongoose 에는 스키마와 모델 이라는 개념이 있는데, 이둘은 혼동하기 쉽다.
스키마는 컬렉션에 들어가는 문서 내부의 각 필드가 어떤 형식으로 돼있는지 정의하는 객체.
이와달리 모델은 스키마를 사용하여 만드는 인스턴스로, DB에서 실제 작업을
처리할수 있는 함수들을 지니고 있는 객체다.

스키마는 모델형태를 거쳐 DB로 들어간다.

22.5.1 스키마 생성 
모델을 만들려면 사전에 스키마를 만들어 줘야한다.
우리는 블로그 포스트에 대한 스키마를 준비할건데, 어떤 데이타가 필요할지 생각해보자.

- 제목
- 내용 
- 태그
- 작성일 

포스트 하나에 이렇게 총 네가지 정보가 필요. 각 정보에 대한 필드 이름과
데이터 타입을 설정하여 스키마를 만듬.

필드 이름			데이터 타입	설명

title			문자열		제목
body			문자열		내용
tags			문자열 배열 	태그
publishedDate	날짜 		작성일 

이렇게 네가지 필드가 있는 스키마를 만들어 보자. 
스키마와 모델에 관련된 코드는 src/models 디렉터리에 작성.
이렇게 디렉터리를 따로 만들어 관리하면 나중에 유지 보수를 좀더 편하게 한다.
models 디렉터리를 만들고, 그 안에 post.js 파일을 만들어 다음코드 작성.

스키마를 만들땐 mongoose 모듈의 Schema 를 사용해 정의.
그리고 각 필드 이름과 필드의 데이터 타입 정보가 들어있는 객체를 작성.
필드의 기본값으로는 default 값 설정.

Schema 에서 기본적으로 지원하는 타입 

String	: 문자열 
Number	: 숫자
Date 	: 날짜
Buffer	: 파일을 담을수 있는 버퍼 
Boolean	: true 또는 false 값
Mixed 	: 어떤 데이터도 넣을수 있는 형식 
(Schema.Types.Mixed)
ObjectId : 객체 아이디. 주로 다른 객체 참조시 사용 
(Schema.Types.ObjectId)
Array	: 배열형태 값으로 [] 으로 감싸서 사용 

스키마 내부에 다른 스키마를 내장시킬수도 있다.

작성방식은 
필드이름 : 스키마 형태 ( String, Number... )

22.5.2 모델 생성 

모델을 만들땐 mongoose.model 함수를 사용.

모델 인스턴스를 만들고, export default 를 통해 내보내 주었다.
여기서 사용한 model() 함수는 기본적으로 두개의 파라미터가 필요.
첫번째 파라미터는 스키마 이름이고, 두번째 파라미터는 스키마 객체.
DB 는 스키마 이름을 정해주면 그이름의 복수 형태로 DB에 컬렉션 이름 생성 
( 's'가 뒤에 붙는다는 말 )

MongoDB 에서 컬렉션 이름을 만들때, 권장되는 컨벤션은 구분자를 사용하지 않고 
복수 형태로 사용하는것.
이 컨벤션을 따르고 싶지 않다면, 세번째 파라미터에 원하는 이름 입력하면 된다.

이런 경우 첫번째 파라미터로 넣은 이름은 나중에 다른 스키마에서 
현재 스키마를 참조해야할때 사용.

22.6 MongoDB Compass 의 설치 및 사용 

MongoDB Compass 는 MongoDB 를 위한 GUI 프로그램으로,
DB 를 쉽게 조회하고 수정할수 있다.

22.7 데이터 생성과 조회 

22장에서는 REST API 를 학습하면서 임시적으로 JS 배열을 사용해 기능구현.
JS 배열 데이터는 시스템 메모리쪽에 위치하기 때문에, 서버를 재시작하면 초기화.
이번에는 배열대신 MongoDB 에 데이터를 등록해 데이터를 보존해보자.

22.7.1 데이터 생성 

기존에 작성한 로직을 모두 새로 작성할 것이므로 posts.ctrl.js 에서 
기존 코드를 모두 지우고 다음코드 입력.

기존 PUT 메서드에 연결했던 replace 는 구현하지 않을것 이므로
해당함수는 제거. 이에따라 posts 라우트의 PUT 메서드를 설정한 부분도 
api/posts/index.js 에서 제거.

블로그 포스트를 작성하는 API 인 write 구현.

포스트의 인스턴스를 만들땐 new 키워드 사용. 그리고 생성자 함수의 파라미터에
정보를 지닌 객체를 넣음.

인스턴스를 만들면 바로 DB에 저장되는것은 아니다.
save() 함수를 실행시켜야 비로소 DB에 저장.
이 함수의 반환값은 Promise 이므로 async/await 문법으로 DB 저장 요청이 
완료될 때까지 await을 사용해 대기할수 있다.
await 을 사용하려면 함수 선언부 앞에 async 키워드를 넣어줌.
또한 await 을 사용할땐 try/catch 문으로 오류 처리 해야함.

코드 작성후 Postman 으로 요청.
서버가 응답한 결과물이 잘 나온다면 Send 세번정도 더 눌러서 응답에 나타나는
_id 값이 계속 바뀌는 것을 확인해보자.

다음으로 MongoDB Compass 에서 좌측 상단의 새로고침 눌러서 blog DB 나타나게함.
선택한뒤 posts 컬렉션을 열어보자.

22.7.2 데이터 조회 

이제 API 를 사용해 데이터를 조회. 데이터를 조회할땐 모델 인스턴스의 find() 사용.
post.ctrl.js 의 list 함수에 대해 작성.

find() 함수 호출후에는 exec() 을 붙여줘야 서버에 쿼리를 요청함.
데이터를 조회할때 특정 조건을 설정하고, 불러오는 제한도 설정함.
이 부분은 추후 페이지네이션 기능을 구현시 알아보자.
코드를 저장하고 서버를 재시작 한후, Postman 으로 요청.

22.7.3 특정 포스트 조회 

이번에는 read API 를 통해 특정 포스트를 id 로 찾아서 조회하는 기능 구현.
특정 id 를 가진 데이터 조회시 findById() 함수 사용.

저장후 Postman 으로 요청하기. URL에서 id 부분에 넣는 파라미터는
이전에 포스트 목록 조회시 나왔던 id 중 하나를 복사.
id 문자를 바꿔서 넣어보면, 404 오류
id 문자를 몇개 지우고 넣어보면, 500 오류 이는 전달받은 id 가 ObjectId 형태가 
아니어서 발생. 나중에 검증작업 거침.

22.8 데이터 삭제와 수정 

22.8.1 데이터 삭제 
이번엔 데이터를 삭제 해보자. 데이터를 삭제할땐 여러 종류의 함수가 있다.

- remove(): 특정 조건을 만족하는 데이터를 모두 지움.
- findByIdAndRemove(): id를 찾아서 지움.
- findOneAndRemove(): 특정 조건을 만족하는 데이터 하나를 찾아서 제거.

우리는 위 함수중 findByIdAndRemove() 를 사용해 데이터 제거.
코드 작성후, Postman 으로 조금전 GET 요청한 주소로 DELETE 요청.
그다음 똑같은 주소로 GET 요청 해보면, 404 오류가 발생. 'Not Found'

22.8.2 데이터 수정.

마지막으로 update 함수 구현.
데이터를 업데이트 할땐 findByIdAndUpdate() 함수 사용.
이 함수 사용시엔 3가지 파라미터 넣음.
첫번째는 id, 두번째는 업데이트 내용, 세번째는 업데이트 옵션.

GET 해서 포스트 목록 받은후, 유효한 id값을 복사한후 해당 id의 포스트를 
업데이트 해보기.

축하합니다! 이제 MongoDB 를 연동한 REST API 개발할수 있게되었다!

22.9 요청 검증

22.9.1 ObjectId 검증 

이 절에서는 요청을 검증하는 방법 알아보자. 
앞서 read API 실행시, id가 올바른 ObjectId 형식이 아니면
500 오류가 발생했다. 이 오류는 보통 서버에서 처리하지않아
내부적으로 문제가 생겼을때 발생함.

잘못된 id 를 전달했다면 클라이언트가 요청을 잘못 보낸것이니 
400 Bad Request 오류를 띄우는것이 맞다. 그러려면 id 값이 올바른 
ObjectId 인지 확인 해야하는데, 이를 검증하는 방법이 있다.

지금 ObjectId 를 검증해야 하는 API 는 read, remove, update
이렇게 세가지다. 모든 함수에서 이를 검증하기 위해 검증코드를
각 함수 내부에 일일이 삽입한다면 똑같은 코드가 중복됨.

코드를 중복하지 않고, 한번만 구현한 다음 여러 라우트에 쉽게 적용하는 
방법이 있다. 바로 미들웨어 를 만드는것. 

posts.ctrl.js 에 미들웨어를 만드는 로직을 작성하고,
src/api/posts/index.js 에서 검증이 필요한 부분에 미들웨어 추가.

이것을 한번더 리팩토링 할수있음.

/api/posts/:id 경로를 위한 라우터를 새로 만들고,
posts 에 해당 라우터를 등록. 이렇게 하면 중복되는 코드가 별로 없어서 
깔끔하지만, 라우트 경로들이 한눈에 들어오지 않으므로 불편할수 있다.
굳이 이렇게 리팩토링 하지않아도 됨.

코드를 작성했으면 GET /api/posts/:id 요청을 할때 
aaaaa 와 같이 일반 ObjectId 의 문자열 길이가 다른, 잘못된 id 넣어보기.

Bad Request 가 뜬다면 적용완료.

22.9.2 Request Body 검증 

이제 write, update API 에서 전달받은 요청내용 검증방법 알아보자.
포스트 작성할땐 서버는 title, body, tags 값을 모두 전달 받아야함.
그리고 클라이언트가 값을 빼먹었을 땐 400 오류가 발생.
지금은 따로 처리하지 않았기 때문에 요청 내용을 비운 상태에서 
write API 를 실행해도 요청이 성공해 비어있는 포스트가 등록됨.

객체를 검증하기 위한 각 값을 if 문으로 비교할수도 있지만,
여기서는 이를 수월하게 해주는 라이브러리 Joi 를 설치하여 사용.

$ yarn add joi

write 함수에서 Joi 를 사용해 요청내용 검증.
설정을 마쳤다면 write API 호출시 Request body 에 필요한 필드가 
빠져있다면 400 오류를 응답하게 되는데, 응답 내용에 에러를 함께 반환.
직접 tags 배열을 제외하고 API 요청을 해보자.

write API 를 수정한뒤 update API 의 경우도 마찬가지로 Joi 를 사용해 
ctx.request.body 를 검증. write API 와 비슷하지만, require가 없다.

이렇게 수정하면, 문자열을 전달해야하는 title 값에 숫자를 넣을경우 에러 발생.

22.10 페이지네이션 구현.

블로그에서 포스트 목록을 볼때 한 페이지에 보이는 포스트의 개수는
10~20개 정도가 적당. 지금 만든 list API 는 현재 작성된 모든 
포스트를 불러오는데, 포스트 개수가 몇백개라면 로딩 속도가 느려진다.
또한 포스트 목록을 볼때 포스트 전체 내용을 보여줄 필요는 없고,
처음 200자 정도만 보여주면 적당. 불필요하게 모든 내용을 보여주면
역시 로딩속도가 지연되고, 트래픽도 낭비된다.

따라서 list API 에 페이지네이션 기능을 구현.

22.10.1 가짜 데이터 생성하기.

페이지네이션 기능을 구현하려면 데이터가 충분해야함.
수작업 으로 하지말고 좀더 편하게 가짜 데이터를 생성하는 스크립트 작성.

작성후 main.js 에서 방금 만든 함수 호출.
데이터 등록을 터미널과 compass 에서 확인하고, createFakeData 호출코드를 
main 파일에서 삭제.

22.10.2 포스트를 역순으로 불러오기 

페이지 기능을 구현하기에 앞서 포스트를 역순으로 불러오는 방법 알아보자.
현재 list API 에서는 포스트가 작성된 순서대로 나열되는데,
블로그에 방문한 사람에게 가장 최근 작성된 포스트를 먼저 보여주는것이 좋다.

이를 구현하려면 list API 에서 exec() 전에 sort() 구문 넣어준다.

sort 함수의 파라미터는 { key: 1 } 형식으로 넣는데,
key 는 정렬할 필드를 설정하는 부분이며, 오른쪽 값을 1로 설정하면
오름차순, -1 로 설정하면 내림차순으로 정렬.
우리는 _id 를 내림차순으로 정렬하고 싶으니 { _id: -1 } 로 설정.

22.10.3 보이는 개수 제한

이번엔 한번에 보이는 개수를 제한.
개수를 제한할땐 limit() 함수를 사용하고, 파라미터에는 제한할 숫자를
넣어준다. 예를 들어 10개로 제한한다면 limit(10) 이라고 입력.

22.10.4 페이지 기능 구현 

페이지 기능을 구현할 준비가 어느정도 되었다.
페이지 기능을 구현하려면 앞 절에서 배운 limit 함수를 사용해야 하고,
추가로 skip 함수도 사용해야 한다.

skip 이란 표현에는 '넘긴다' 는 의미가 있다.
skip 함수에 파라미터로 10을 넣어주면, 처음 열개를 제외하고
그다음 데이터를 불러온다. 20을 넣어준다면 처음 20개를 제외하고 
그 다음 데이터 열개를 불러온다.

skip 함수의 파라미터에는 (page -1) * 10 을 넣어주면 된다.
1페이지 에는 처음 열개를 불러오고, 2페이지에는 그다음 열개를 불러온다.
page 값은 query 에서 받아오도록 설정.
이값이 없으면 page 값을 1로 간주하여 코드를 작성.

이렇게 하면 http://localhost:4000/api/posts?page=2 형식으로 
페이지를 지정하여 조회.

22.10.5 마지막 페이지 번호 알려주기 

지금도 페이지로서 기능은 충분하지만, 조금더 기능을 추가해보자.
마지막 페이지를 알수 있다면 클라이언트가 더욱 편하다.
응답 내용의 형식을 바꾸어 새로운 필드를 설정하는 방법, Response 헤더중 Link 설정하는방법,
커스텀 헤더를 설정하는 방법으로 이 정보를 알려 줄 수도 있다.

이중에서 커스텀 헤더를 설정하는방법 사용.
Last-Page 라는 커스텀 HTTP 헤더를 설정했다.
이값이 제대로 나타나는지 Postman 을 이용해 확인해보자.

22.10.6 내용 길이 제한
이제 body 의 길이가 200자 이상이면 뒤에 '...' 을 붙이고 문자열을 자르는 기능 구현.
find() 를 통해 조회한 데이터는 mongoose 문서 인스턴스의 형태 이므로
데이터를 바로 변형할 수 없다.
그 대신 toJSON 함수를 실행하여 JSON 형태로 변환한뒤 변형을 일으켜 줘야한다.

22.11 정리 

이 장에서는 REST API 에 MongoDB 를 연동하는 방법을 배우고,
쿼리를 작성해 페이지네이션 기능까지 구현.
MongoDB 는 이책에서 다룬것 외에도 더욱 다양하고 복잡한 쿼리도 설정할수 있다.

백엔드는 결국 여러가지 조건에 따라 클라이언트에서 전달받은 데이터를
등록하고 조회하고 수정하는 것.
우리가 만든 백엔드 서버에는 현재 한종류의 데이터 모델과 REST API 밖에 없지만,
프로젝트 규모에 따라 더욱 많은 종류의 모델과 API 를 관리할 수도 있다.

