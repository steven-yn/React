
11.5.2 useReducer 사용하기.

useState 로 함수형 업데이트 사용하는 대신, useReducer 를 사용하여
onToggle onRemove 계속 새로워지는 문제 해결하기.

useReducer 사용시엔 원래 두번쨰 파라미터에 초기 상태를 넣어야 한다.
대신 undefined 넣고, 세번째에 초기 상태 만들어주는 함수 createBulkTodos
넣어주면 컴포넌트가 맨 처음 렌더링 될때만 createBulkTodos 함수 호출.

useReducer 사용 방법은 기존 코드를 많이 고쳐야 한다는 단점이 있지만,
상태를 업데이트 하는 로직을 모아서 컴포넌트 바깥에 둘수 있다는 장점.
성능상으로는 두가지 방법이 비슷하다.

11.6 불변성의 중요성

기존 데이터를 수정할 때 직접 수정하지 않고, 새 배열을 만든 다음 새로운 객체를 만들어서,
필요한 부분만 교체해 주는 방식으로 구현.
업데이트가 필요한 곳에서는 아예 새로운 배열 혹은 새로운 객체를 만들기 때문에,
React.memo 를 사용했을 때 props 가 바뀌었는지 혹은 바뀌지 않았는지를 알아내서
리렌더링 성능을 최적화 해줄수 있다.

이렇게 기존 값 직접 수정 하지 않으면서 새로운 값을 만들어 내는 것을 '불변성을 지킨다'

불변성이 지켜지지 않으면 객체 내부의 값이 새로워져도 바뀐것 감지하지 못함.
따라서 React.memo 에서 서로 비교하여 최적화가 불가능.

추가로 전개 연산자 (...) 를 사용하여 객체나 배열내부 값을 복사할때는
얕은 복사 (shallow copy) 를 하게된다.
즉, 내부 값이 완전히 새로 복사되는것이 아닌 가장 바깥족에 있는 값만 복사.

따라서 내부의 값이 객체, 배열 이라면 내부의 값 또한 따로 복사 해야함.
객체안에 있는 객체 같이 구조가 정말 복잡해진다면 불변성 유지 업데이트도 까다로워진다.
이렇게 복잡할 경우 immer 라는 라이브러리 도움을 받으면 정말 편하게 작업.

11.7 TodoList 컴포넌트 최적화하기.

리스트에 관련된 컴포넌트 최적화시에는 리스트 내부에서 사용하는 컴포넌트도 최적화 해야하고,
리스트로 사용되는 컴포넌트 자체도 최적화 해주는것이 좋다.

TodoList 만 React.memo 를 해주는것은 성능에 영향을 주지 않고있다.
왜냐하면, 부모 컴포넌트인 App 컴포넌트가 리렌더링 되는
유일한 이유가 todos 배열이 업데이트 될 때 이기 때문입니다.

즉, TodoList 컴포넌트는 불필요한 리렌더링이 발생하지 않는다.
하지만 App 컴포넌트에 다른 state 가 추가되어 해당 값들이 업데이트 된다면
TodoList 도 불필요한 리렌더링 발생될수도 있다.
따라서 미리 최적화 해준것.

리스트 관련 컴포넌트를 작성할 때는 리스트 아이템과 리스트, 이 두가지 컴포넌트 최적화
하는것 잊지 말것.
그러나 내부 데이터가 100개를 넘지 않거나 업데이트가 자주 발생하지 않는다면,
이런 최적화 작업 반드시 할필요는 없다.

11.8 react-virtualized 를 사용한 렌더링 최적화.

현재 컴포넌트가 맨처음 렌더링 될때 2500개 컴포넌트 중 2,491개는
스크롤 하기 전에는 보이지 않음에도 불구하고 렌더링이 이루어진다.
나중에 todos 배열에 변동이 생길때도 TodoList 컴포넌트 내부의 map 함수에서
배열의 처음부터 끝까지 컴포넌트로 변환해 주는데, 이중에서 2,491개는 보이지 않으므로
시스템 자원 낭비다.

이런점은 react-virtualized 를 사용해서 스크롤 되기 전에 보이지 않는 컴포넌트는
렌더링 하지않고 크기만 차지하게끔 할수 있다.
만약 스크롤 되면 해당 스크롤 위치에서 보여 주어야 할 컴포넌트를 자연스럽게 렌더링.

11.8.1 최적화 준비.

react-virtualized 에서 제공하는 List 컴포넌트를 사용하여 TodoList 최적화.
최적화 수행하려면 사전에 먼저 하는 작업이 있는데,
바로 각 항목의 실제 크기를 px 단위로 알아내는것.
이 값은 CSS 파일에서 직접 계산해도 되지만, 크롬 개발자 도구의
좌측 상단에 있는 아이콘을 눌러서 크기를 알고 싶은 항목에 커서를 대봐서 확인 가능.

각 리스트 항목 크기는 가로 512px, 세로 57px
크기를 알아낼때 두번째 항목 확인 해야하는데, 두번째 항목 부터 테두리가 포함되기 때문.

11.8.2 TodoList 수정.

List 컴포넌트 사용하기위해 rowRenderer 라는 함수를 새로 작성.
이 함수는 react-virtualized 의 List 컴포넌트에서 각 TodoItem을 렌더링 할때 사용.
이 함수를 List 컴포넌트의 props 로 설정 해줘야함.
이 함수는 파라미터로 index, key, style 값을 객체 타입으로 받아옴.

List 컴포넌트를 사용할 때는 해당 리스트의 전체 크기와 각 항목의 높이,
각 항목을 렌더링 할때 사용해야하는 함수, 그리고 배열을 props 로 넣어줘야함.
그러면 이 컴포넌트가 전달받은 props를 사용하여 자동으로 최적화 해줌.

11.8.3 TodoListItem 수정.

render 함수에서 기존에 보여주는 내용을 div로 한번 감싸고, 해당 div에는
TodoListItem-virtualized 라는 className 설정 및 props로 받은 style 적용.

TodoListItem-virtualized 는 클래스는 컴포넌트 사이사이 테두리를 제데로 쳐주고,
홀수 번째 / 짝수 번째 항목에 다른 배경 색상 설정 하기 위함.

React.memo 함수의 두번째 인자에 prevPros 와 nextProps 를 파리미터로
받아오는 함수를 넣어주었다.
여기서 prevProps 는 이전 Props, nextProps는 업데이트 할 Props 를 의미.
react-virtualized 에서 매번 style 객체를 새로 만들기 때문에
React.memo 를 사용해도 렌더링 항목 개수만 줄어들뿐, 낭비 렌더링이 방지되지 않는다.
이 두번째 인자로 전달하는 함수에서 true를 반환하면 컴포넌트 유지,
false를 반환하면 컴포넌트 리렌더링. 현재는 todo 값 동일하면 리렌더링 하지않고
그대로 유지하도록 설정.

11.9 정리
리액트 컴포넌트 렌더링은 기본적으로 빠르기 때문에 컴포넌트 개발할때
최적화 작업에 대해 너무 큰 스트레스 받거나 모든 컴포넌트에 일일이 React.memo
작성할 필요는 없다.
단, 리스트와 관련된 컴포넌트 만들때 보여줄 항목이 100개 이상이고 업데이트가 자주 발생?
이 방식들을 사용하자.

12장 immer를 사용하여 더 쉽게 불변성 유지하기

11장 에서는 업데이트 성능 최적화 방법, 불변성 유지 하며 상태 업데이트가
중요한 이유를 배움.
전개 연산자와 배열 내장 함수 사용하면 간단하게 배열이나 객체 복사하고
새로운 값을 덮어 쓸수 있다.
하지만 객체 구조가 엄청나게 깊어지면 불변성 유지하며 업데이트하기가 힘들어진다.

값 하나를 업데이트 하기위해 코드를 열줄정도 작성해야함.
이렇게 전개 연산자를 자주 사용 하는 이유는 불변성 유지 하며 원하는 값 새로 지정하기위함.

이럴때 전개 연산자 여러번 사용하는것은 번거롭고 가독성이 좋지못하다.

이런 상황에 immer 라이브러리 사용.
구조가 복잡한 객체도 매우 쉽게 불변성 유지 업데이트가 가능해진다.

12.1 immer 설치하고 사용법 알아보기

12.1.3 immer 사용법.

ex)
import produce from 'immer';
const nextState = produce(originalState, draft => {
	// 바꾸고 싶은 값 바꾸기
	draft.somewhere.deep.inside = 5;
})

produce(수정하고 싶은 상태, 상태를 어떻게 업데이트할지 정의된 함수) : 
==> produce(state, 함수)
두번째 파라미터 함수 내부에서 원하는값 변경시,
produce 함수가 불변성 유지를 대신해주면서 새로운 상태 생성.
첫번째 파라미터로 함수 형태를 입력했다면, 업데이트 함수를 반환함.

이 라이브러리 핵심은 ' 불변성 신경 쓰지 않는것처럼 코드 작성하되, 불변성 관리는 제대로 '
단순히 깊은곳 위치하는 값 바꾸는 것 외에 배열을 처리할때도 매우쉽고 편함.

12.1.4 App 컴포넌트에 immer 적용.

immer를 사용하여 컴포넌트 state 작성시 에는
객체 안의 값을 직접 수정하거나, 배열에 직접적인 변화를 일으키는
push, splice 등의 함수를 사용해도 무방.
immer 는 불변성 유지하는 코드가 복잡할 때만 사용해도 충분함.

12.1.5 useState 의 함수형 업데이트 와 함께 immer

immer 에서 제공하는 produce 함수를 호출시, 첫 파라미터가 함수라면
업데이트 함수를 반환 ( state를 생략하고 함수만 사용 한다. )

state 에서 set 쪽 함수를 끌어다가 쓰면 되는듯,..

12.2 정리

이 라이브러리는 컴포넌트의 상태 업데이트가 조금 까다로울때 사용하면 좋다.
추후 상태 관리 라이브러리인 리덕스를 배워서 사용할 때도 immer를 쓰면 코드를 쉽게.
만약 immer 를 사용하는게 오히려 불편하면 사용하지 않아도 좋다.

13장 리액트 라우터로 SPA 개발하기

13.1 SPA 란?
SPA는 싱글 페이지 애플리케이션 약어.
말 그대로 한개의 페이지로 이루어진 애플리케이션

전통적인 웹페이지는 사용자가 다른 페이지 이동할때마다 새로운 html 받아오고,
페이지 로딩 할때 마다 서버에서 리소스 전달받아 해석한뒤 화면에 보여주기.
이렇게 사용자에게 보이는 화면은 서버측에서 준비.
사전에 html 만들어 제공 하거나, 데이터에 따른 유동적인 html 생성 해주는
템플릿 엔진 사용도 함.

요즘은 웹에서 제공되는 정보가 정말 많기 때문에 새로운 화면 보여줄 때 마다 
서버측에서 모든 뷰를 준비한다면 성능상 문제가 발생.
예로 대량의 트래픽이나, 클라이언트가 몰려 서버에 높은 부하 등.
속도와 트래픽 측면에서는 캐싱 과 압축 을 해서 서비스 제공하면 어느정도 해결은 되지만,
사용자와 인터랙션이 자주 발생하는 모던 웹 애플리케이션 에서는 적당하지 않을수도 있다.
애플리케이션 내에서 화면 전환이 일어날때마다 html을 계속 서버에 새로 요청하면
사용자의 인터페이스에서 사용하고 있던 상태를 유지하는거도 번거롭고,
바뀌지 않는 부분까지 새로 불러와서 보여주어야 한다.
따라서 불필요한 로딩이 있어서 비효율적 이다.

그래서 리액트 같은 라이브러리 혹은 프레임워크를 사용해 뷰 렌더링을 사용자의 브라우저가
담당하도록 하고, 먼저 애플리케이션 을 브라우저에 불러와서 실행 시킨다.
그후에 클라이언트 와의 인터랙션이 발생하면 필요한 부분만 JS를 사용하여 업데이트.
만약 새로운 데이터가 필요하다면 서버 API를 호출하여 필요한 데이터만 새로 불러와 사용가능.

싱글 페이지라고 해서 화면이 한종류 일까?
예를 들어 블로그 개발한다면 홈, 포스트 목록, 포스트, 글쓰기 등의 화면이 있다.
SPA 경우 서버에서 사용자에게 제공하는 페이지는 한 종류지만,
해당 페이지에서 로딩된 JS와 현재 사용자 브라우저 주소 상태에 따라
다양한 화면 보여줄수 있음.

다른 주소에 다른화면 보여주는것을 '라우팅' 이라함.
리액트 라이브러리 자체에 이 기능이 내장되진 않음.
그대신 브라우저의 API를 직접 사용하여 이를 관리하거나,
라이브러리를 사용하여 이작업을 더욱 쉽게 구현 가능.

리액트 라우팅 라이브러리 에는 react-router, reach-router, Next.js 등
여러 가지가 존재. 그중 역사가 가장 길고 사용빈도가 가장 높은 리액트 라우터 사용.

리액트 라우터는 클라이언트 사이드에서 이루어지는 라우팅을 아주 간단히 구현하도록 해준다.
더 나아가서 나중에 서버 사이드 렌더링을 할때도 라우팅을 도와주는 컴포넌트 제공해줌.

13.1.1 SPA 의 단점

SPA의 단점은 앱의 규모가 커지면 JS 파일이 너무 커진다는 것.
페이지 로딩시 사용자가 실제로 방문하지 않을수도 있는 페이지의 스크립트도 불러오기 때문.
나중에 배울 코드 스플리팅 ( code splitting ) 을 사용하면
라우트 별로 파일들을 나누어서 트래픽과 로딩속도 개선할수 있다.

리액트 라우터처럼 브라우저에서 JS를 사용하여 라우팅 관리하는 것은
JS를 실행하지 않는 일반 크롤러에서는 페이지의 정보를 제대로 수집해 가지 못한다는
잠재적인 단점이 있다. 그렇기 때문에 구글, 네이버, 다음 같은 검색 엔진 결과에
페이지가 잘 나타나지 않을 수도 있다.
구글 검색 엔진에서 사용하는 크롤러는 JS를 실행 해 주는 기능이 탑재되어있지만,
크롤링 하는 모든 페이지에서 JS를 실행하고 있지는 않다. (2019 기준)
또한, JS가 실행될 때까지 페이지가 비어있기 때문에
JS 파일이 로딩되는 짧은 시간동안 흰 페이지만 나타날수도 있는 단점 존재.
다행히 나중에 배울 서버사이드 렌더링 (server-side rendering) 을 통해
모두 해결할 수 있다.

13.2 프로젝트 준비 및 기본적인 사용법

실습의 흐름

-1) 프로젝트 생성 및 리액트 라우터 적용
-2) 페이지 만들기
-3) Route 컴포넌트로 특정 주소에 컴포넌트 연결
-4) 라우트 이동하기
-5) URL 파라미터와 쿼리 이해하기
-6) 서브 라우트
-7) 부가기능 알아보기

13.2.1 프로젝트 생성 및 라이브러리 설치

src/index.js 파일에 
import { BrowserRouter } from "react-router-dom"; 한후

ReactDOM.render(
  <BrowserRouter>
    <App />
  </BrowserRouter>,
  document.getElementById("root")
);

와 같이 BrowserRouter 로 컴포넌트 감싸면 됨.
이 컴포넌트는 웹 애플리케이션 에 HTML5의 History API 를 사용하여
페이지를 새로고침 하지 않고도 주소를 변경하고, 
현재 주소에 관련된 정보를 props로 쉽게 조회하거나 사용할수 있도록 해준다.

13.2.3 페이지 만들기.

이제 라우트로 사용할 페이지 컴포넌트 만들 차례.
사용자가 웹 사이트 들어왔을 때 맨 처음 보여줄 Home 컴포넌트와
웹 사이트 소개하는 About 컴포넌트 만들기.

13.2.4 Route 컴포넌트로 특정 주소에 컴포넌트 연결

App.js 에 Route 컴포넌트 사용해서 Home과 About 컴포넌트 띄우기

/about 경로가 / 규칙에도 일치하므로 exact 라는 props 를 true로 설정.

13.2.5 Link 컴포넌트 사용하여 다른 주소 이동하기.

Link 컴포넌트는 클릭시 다른 주소 이동시켜주는 컴포넌트.
일반 웹 애플리케이션 에서는 a 태그 사용.
리액트 라우터 사용시엔 이 태그를 직접 사용 X
이 태그는 페이지를 전환하는 과정에서 페이지를 새로 불러오기 때문에
애플리케이션 이 들고 있던 상태들을 모두 날려버리게 됨.
렌더링된 컴포넌트들도 모두 사라지고 다시 처음부터 렌더링.

Link 컴포넌트를 사용하여 페이지 전환시, 페이지를 새로 불러오지 않고
애플리케이션 은 그대로 유지한 상태에서 HTML5 History API 사용해
페이지 주소만 변경해줌.
Link 컴포넌트 자체는 a 태그로 이루어져 있지만, 페이지 전환을 방지하는 기능 내장.

