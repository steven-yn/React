18장 리덕스 미들웨어를 통한 비동기 작업관리

리액트 웹 애플리케이션 에서 API 서버를 연동 할땐 API 요청에 대한 상태도
잘 관리해야한다.
요청이 시작되었을 땐 로딩 중임을,
요청이 성공하거나 실패했을 땐 로딩이 끝났음을 명시해야 한다.
요청이 성공하면 서버에서 받아온 응답에 대한 상태를 관리하고,
요청이 실패하면 서버에서 반환한 에러에 대한 상태를 관리해야 한다.

리액트 프로젝트에서 리덕스를 사용하고 있으며 이러한 비동기 작업 관리시,
'미들웨어' 를 사용하여 매우 효율적으로 상태 관리를 할수있다.

18.1 작업 환경 준비

CRA(create-react-app) 사용하여 새 리액트 프로젝트 생성.
리덕스를 사용하여 카운터 구현.

18.2 미들웨어란?

리덕스 미들웨어는 액션을 디스패치 했을때 리듀서에서 이를 처리하기에 앞서
사전에 지정된 작업들을 실행한다. 미들웨어는 액션과 리듀서 사의 중간자.

액션 -> 미들웨어 -> 리듀서 -> 스토어

리듀서가 액션을 처리하기 전에 미들웨어가 할수 있는 작업은 여러가지다.
전달받은 액션을 콘솔에 기록, 전달받은 액션정보 를 기반으로 액션 취소,
다른 종류의 액션을 추가로 디스패치 할수도 있다.

18.2.1 미들웨어 만들기

실제 프로젝트 를 작업할 때 미들웨어 를 직접 만들어서 사용할일은
그리 많지 않다. 다른 개발자가 만든 미들웨어를 사용하면 되기 때문.
하지만 미들웨어가 어떻게 작동하는지 이해하려면 직접 만들어 보는게
가장 효과적.
간단한 미들웨어를 직접 만들어 보면 제대로 이해할수 있다.
원하는 미들웨어를 찾을수 없을땐 상황에 따라 직접 만들거나
기존 미들웨어들을 커스터마이징 하여 사용할 수도 있다.

여기서는 액션이 디스패치 될 때마다 액션의 정보와 액션이 디스패치 되기 전후의
상태를 콘솔에 보여주는 로깅 미들웨어 작성해보자.

미들웨어는 결국 함수를 반환하는 함수이다.
여기에 있는 함수에서 파라미터로 받아오는 store는 리덕스 스토어 인스턴스를,
action은 디스패치된 액션을 가리킴.
반면에 next 파라미터는 함수 형태이며, store.dispatch 와 비슷한 역할.
큰 차이점은, next(action) 을 호출하면 그다음 처리할 미들웨어에게
액션을 넘겨주고, 만약 그다음 미들웨어 가 없다면 리듀서 에게 액션을 넘겨준다.

미들웨어 내부에서 store.dispatch 를 사용하면 첫번째 미들웨어부터 다시처리.
만약 미들웨어 에서 next를 사용하지 않으면 액션이 리듀서에 전달되지 않는다.
즉, 액션이 무시됨.

이제 미들웨어를 마저 구현해보자.
다음 정보를 순차적으로 콘솔에 보여줌.
-1. 이전상태
-2. 액션정보
-3. 새로워진 상태 

만든 리덕스 미들웨어 스토어에 적용하기.
미들웨어 는 스토어를 생성하는 과정에서 적용한다.

액션 정보와 업데이트 전후 상태가 콘솔로그에 나타남.
미들웨어 에서는 여러 종류 작업 처리가능.
특정 조건에 따라 액션을 무시하게 하거나,
특정 조건에 따라 액션 정보를 가로채서 변경한후 리듀서 에게 전달가능.
특정 액션에 기반하여 새로운 액션을 여러번 디스패치 할수 있다.

이런 미들웨어 속성을 사용해 네트워크 요청과 같은 비동기 작업 관리하면
매우 유용.

18.2.2 redux-logger 사용하기.

이번엔 오픈소스 커뮤니티에 이미 올라온 redux-logger 미들웨어를
설치 및 사용하기. 방금 만든 loggerMiddleware 보다 훨씬 더
잘 만들어진 라이브러리 이며, 브라우저 콘솔에 나타나는 형식도 깔끔.

yarn add redux-logger

사용해보면 콘솔에 색상도 입혀지고, 액션 디스패치 시간도 나타난다.
리덕스 미들웨어를 사용할땐 이렇게 완성된 미들웨어 를 라이브러리로
설치해서 사용하는 경우가 많다.

18.3 비동기 작업을 처리하는 미들웨어 사용.

이제 오픈소스 커뮤니티에 공개된 미들웨어를 사용해 리덕스를 사용하고있는
프로젝트에서 비동기 작업을 더욱 효율적으로 관리해보자.

비동기 작업 처리할때 도움주는 미들웨어 는 다양함.

redux-thunk : 비동기 작업을 처리할때 가장 많이 사용.
객체가 아닌 함수 형태의 액션을 디스패치 할수 있게 해줌.

redux-saga : redux-thunk 다음으로 많이 사용.
특정 액션이 디스패치 됐을때 정해진 로직에 따라 다른 액션을 디스패치
시키는 규칙을 작성해 비동기 작업 처리할수 있게해줌.

18.3.1 redux-thunk

리덕스를 사용하는 프로젝트에서 비동기 작업 처리할때 가장 기본적으로 사용.
리덕스의 창시자인 댄 아브라모프 가 만들었으며, 리덕스 공식 매뉴얼 에서도
이 미들웨어를 사용하여 비동기 작업 다루는 예시 보여줌.

18.3.1.1 Thunk 란?

Thunk 는 특정 작업을 나중에 할 수 있도록 미루기 위해 함수형태로 감싼것.
thunk 함수를 만들어서 디스패치 하면 리덕스 미들웨어가 그 함수를 전달받아
store 의 dispatch 와 getState 를 파라미터로 넣어서 호출.

sampleThunk = () => (dispatch, getState) => {
	// 현재 상태를 참조할 수 있고,
	// 새 액션을 디스패치 할수도 있다.
}

18.3.1.2 미들웨어 적용하기

yarn add redux-thunk

18.3.1.3 Thunk 생성함수 만들기.

redux-thunk 는 액션생성함수 에서 일반 액션 객체를 반환하는 대신
함수를 반환. increaseAsync 와 decreaseAsync 함수를 만들어
카운터 값을 비동기 적으로 변경시켜 보자.

비동기 함수를 호출하여 실행시키면, 처음에 함수형태의 액션이 디스패치 되고,
다음에 객체형태의 액션이 디스패치 된다.

18.3.1.4 웹 요청 비동기 작업 처리하기.

thunk 의 속성을 활용해 웹 요청 비동기 작업 처리하는 방법 알아보자.
웹 요청을 연습하기 위해 JSONPlaceholder 에서 제공되는 가짜 API 사용.

사용할 API :

# 포스트 읽기 (:id는 1~100 사이 숫자)
GET https://jsonplaceholder.typicode.com/posts/:id

# 모든 사용자 정보 불러오기
GET https://jsonplaceholder.typicode.com/users

API 를 호출시 주로 Promise 기반 웹 클라이언트 인 axios 사용.

yarn add axios 

API 를 모두 함수화. 각 API를 호출하는 함수를 따로 작성하면,
나중에 사용할때 가독성도 좋고 유지 보수도 쉬워진다.
다른파일에서 불러와 사용하도록 export 사용하여 내보내주기.

새로운 리듀서를 만들어 보자. 위 API 사용하여 데이터를 받아와 상태를 관리할
sample 이라는 리듀서 생성.

코드에서 반복되는 로직이 꽤 있다.
우선 컨테이너 컴포넌트 를 사용해 데이터 요청을 성공적으로 처리하고,
나중에 반복되는 로직을 따로 분리하여 재사용하는 형태로 코드 리팩토링.

데이터를 렌더링할 프레젠테이셔널 컴포넌트 작성.
이 컴포넌트를 작성하려면 먼저 API 를 통해 전달받은 데이터의 형식이
어떤 구조인지 확인해야함.

post 의 경우 userId, id, title, body

user 의 경우 id, name, username, email, address, phone, website, company

이번에 만들 컴포넌트 는 post 의 경우 title 과 body만,
user 의 경우 username 과 email 만.

데이터를 불러와서 렌더링 해줄 땐 유효성 검사를 해주는게 중요.
예를 들어 post && 을 사용하면 post 객체가 유효할 때만
그 내부의 post.title 혹은 post.body 값을 보여줌.
만약 데이터가 없는 상태라면 post.title 을 조회하려 할때
JS 오류가 발생하니 반드시 유효성 검사.

users 도 마찬가지로 데이터가 배열 형태로 들어올 것을 기대하고 
map 함수를 사용한다. 하지만 유효성 검사 하지않으면 null 값에 대해
map 함수를 호출하고, 오류가 발생함.

18.3.1.5 리팩토링

API 를 요청해야 할때 마다 17줄 정도 되는 thunk 함수를 작성하는것과,
로딩 상태를 리듀서에서 관리하는 작업은 귀찮을 뿐 아니라 코드도 길어지게 만듬.
그러므로 반복되는 로직을 따로 분리하여 코드양 줄이기.

API 요청을 해주는 thunk 함수를 한줄로 생성할수 있게 해주는 유틸 함수.
액션 타입과 API 를 요청하는 함수를 파라미터로 넣어주면 나머지 작업을
대신 처리해줌. 코드가 많이 축소됨.

요청의 로딩 상태 관리 작업 개선.
기존에는 리듀서 내부에서 각 요청에 관련된 액션이 디스패치 될 때마다
로딩 상태를 변경 해 줬다. 이 작업을 로딩상태만 관리하는 리덕스 모듈
따로 생성하여 처리하자.

요청이 시작될때 디스패치 할 액션.
{
	type: 'loading/START_LOADING',
	payload: 'sample/GET_POST'
}

위 액션이 디스패치 되면 loading 리듀서가 관리하는 상태에서
sample/GET_POST 값을 true로 설정.
만약 기존상태에 sample/GET_POST 필드가 없다면 새로 값을 설정.

그리고 요청이 끝나면 FINISH 를 디스패치 해줌.
그러면 기존에 true 로 설정한 값을 다시 false 로 전환해줌.
루트 리듀서에 포함시키기.

loading 리덕스 모듈에서 만든 액션 생성 함수는 앞에서 만든
createRequestThunk 에서 사용.

SampleContainer 에서 로딩상태 조회.

sample 리듀서에서 불필요 코드 지우기.
이제 sample 리듀서는 로딩중에 대한 상태를 관리할 필요가 없다.
성공했을때 케이스만 잘 관리해주면 됨.
추가로 실패 케이스를 관리하고 싶다면, _FAILURE 가 붙은 액션을
리듀서에서 처리해주면 된다.
혹은 컨테이너 컴포넌트 에서 try/catch 구문으로 에러값을 조회.
( catch(e) 일떄 )

SampleContainer.js - useEffect

redux-thunk 를 처음 쓸때는 비록 작성할 코드가 많아서 불편할수 있지만,
유용한 함수와 리듀서를 만들어 상태를 관리하면 매우 깔끔한 코드로 기능구현.
