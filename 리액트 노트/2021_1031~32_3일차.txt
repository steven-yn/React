6장 컴포넌트 반복

6.1 자바스크립트 배열의 map() 함수

코드가 복잡해지고 코드양이 늘어날수록, 파일용량도 증가하고 보여줄 데이터가 유동적이라면
반복되는 코드를 일일히 작성하는것은 관리가 불가능하다.
6장에서는 리액트 프로젝트에서 반복적인 내용을 효율적으로 보여주고 관리하는 방법 알아보자.

map 함수를 사용하여 반복되는 컴포넌트 렌더링
파라미터로 전달된 함수를 사용해서 배열내 각요소를 원하는 규칙에 따라 변환후
그 결과로 새로운 배열 생성.

arr.map(callback, [thisArg])

callback : 새로운 배열의 요소를 생성하는 함수. 세가지 파라미터.
	- currentValue	: 현재 처리하는 있는 element
	- index			: 현재 처리하고 있는 element의 index값
	- array			: 현재 처리하고 있는 원본 array
	
thisArg (선택 항목) : callback 함수 내부에서 사용할 this 레퍼런스

ex) 
var processed = numbers.map(function(num){
    return num * num;
});

6.2 데이터 배열을 컴포넌트 배열로 변환하기

6.3 Key

유동적인 데이터를 다룰때는 원소를 새로 생성할수도, 제거할 수도, 
수정할 수도 있다.
Key 가 없을때는 Virtual DOM을 비교하는 과정에서 리스트를 순차적으로 비교하면서
변화를 감지하지만,
Key가 있다면 어떤 변화가 일어났는지 더욱 빠르게 알아차린다.
Key는 컴포넌트 배열을 렌더링 했을때 어떤 원소에 변동이 있었는지 알아내려고 사용.

6.3.1 Key 설정

key 값을 설정할때는 map 함수의 인자로 전달되는 함수 내부에서 props 설정하듯.
key값은 언제나 unique 해야함. 데이터가 가진 고유값을 key 값으로,,

고유번호가 없는 경우?
map함수에 전달되는 콜백 함수의 인수인 index값을 사용.
고유한 값이 없을때만 index를 key로 사용해라.
index를 key로 사용하면 배열이 변경될떄 효율적인 렌더링 하지못한다.

6.4 응용

동적인 배열 렌더링 구현.
index값을 key로 쓰면 비효율적인데, 이런 상황에 어떻게 고유값 만드는가?

-1 초기상태 설정하기
-2 데이터 추가기능 구현하기
-3 데이터 제거기능 구현하기

6.4.1 초기상태 설정.

Iter 컴포넌트에서 useState 사용하여 상태 설정하기.
세가지 상태 : 데이터 배열, 텍스트 입력받기(input), 고유 id

객체 형태로 이루어진 배열 만들자. 해당 객체엔 문자열 + 고유 id 존재

6.4.2 데이터 추가기능 구현하기

ul 태그의 상단에 input 과 button 렌더링, input 상태 관리.

배열에 새항목 추가시 배열의 push()를 이용하지 않고 concat을 사용.
push는 기존 배열 자체를 변경, concat은 새로운 배열을 만들어준다.

리액트에서 상태를 업데이트 할때는 기존 상태를 그대로 두면서 새로운 값을 상태로 설정해야함.
-> 불변성 유지.
불변성 유지는 리액트 컴포넌트 성능 최적화의 핵심 !!!

onClick 함수에서 새로운 항목을 추가할때 객체의 id 값은 nextId 사용.
클릭될때마다 값이 1씩 올라간다. button 클릭시 기존 input 비우기 까지.

6.4.3 데이터 제거 기능 구현하기

각항목 더블클릭시 해당 항목 화면에서 사라지기.
불변성 유지 업데이트 사용. 이때는 filter 함수 사용.
함수 인자에 매개변수 만들어서 조건과 연산자로 가려냄.

HTML 요소를 더블클릭할때 이벤트는 onDoubleClick.
onRemove 함수 만들어서 li요소에 이벤트 등록.

6.5 정리

- 반복되는 데이터 렌더링
- 유동적인 배열.
- key값 설정. unique함 필수
- concat, filter 사용.

7장 컴포넌트의 라이프사이클 메서드

라이프사이클 ( 수명주기 ) 는 모든 리액트 컴포넌트에 존재.
컴포넌트의 수명은 페이지에 렌더링 되기 전인 준비과정 ~ 페이지 사라질때 끝남.

프로젝트 진행하다 보면 컴포넌트 처음 렌더링시 어떤 작업 처리나
컴포넌트 업데이트 하기 전후로 어떤 작업 처리 하거나, 불필요한 업데이트 방지 할떄도 있다.

이때는 라이프사이클 메서드 사용. 이것은 클래스형 컴포넌트만 사용.
Hooks 로 비슷한 작업을 할수있다. 8장에서 한다.

7.1장 라이프사이클 메서드의 이해

종류는 총 9가지.
Will : 어떤 작업 작동전 실행.
Did : 어떤 작업 작동후

이 메서드들은 컴포넌트 클래스 에서 덮어 써 선언.

라이프사이클 은 총 3가지 ( 마운트, 업데이트, 언마운트 ) 카테고리로 나눔.

마운트 : 페이지에 컴포넌트 나타남.
언마운트 : 페이지에서 컴포넌트 사라짐.
업데이트 : 컴포넌트 정보를 업데이트 ( 리렌더링 )

constructor : 컴포넌트 새로 만들떄마다 호출 ( 생성자 메서드 )
getDSFP : props 에 있는 값을 state에 넣을때
render : 우리가 준비한 ui 렌더링
componentDidMount : 컴포넌트가 웹 브라우저 상에 나타난후 호출 메서드

업데이트
컴포넌트는 4가지 경우에 업데이트
1. 부모 컴포넌트에서 넘겨주는 props가 바뀔떄
2. 컴포넌트 자신이 들고있는 state가 setState를 통해 바뀔때
3. 부모 컴포넌트 리렌더링 될때
4. this.forceUpdate로 강제 렌더링 트리거시

7.2 라이프사이클 메서드 살펴보기

7.2.1 render() 함수.

컴포넌트 모양새 정의. 유일한 필수 메서드.

이 메서드 안에서 props state 접근 할수 있으며, 리액트 요소 반환.
요소는 div 건 외부 컴포넌트 가 될수도 있다.
null, false를 반환 할수도 있다.

이 메서드 안에서는 이벤트 설정이 아닌곳에서 setState를 사용하면 안되며,
브라우저의 DOM에 접근도 안됨. DOM 정보를 가져오거나 state 변화는
componentDidMount 에서 처리.

8장 Hooks 

Hooks 는 함수 컴포넌트에서도 상태 관리 할수 있는 useState
렌더링 직후 작업을 설정하는 useEffect 등의 기능을 제공

8.2 useEffect

리액트 컴포넌트가 렌더링 될 때마다 특정 작업을 수행하도록 설정할 수 있는 Hook
componentDidMount 와 componentDidUpdate 를 합친 형태

8.2.1 마운트 될 때만 실행하고 싶을때

useEffect에서 설정한 함수를 컴포넌트가 화면에 맨처음 렌더링 될때만 실행하고,
업데이트 ( 리렌더링 ) 될때는 실행하지 않으려면 함수의 두번째 파라미터로 비어있는 배열
넣어주기. ex) , []

8.2.2 특정값이 업데이트 될 때만 실행하고 싶을때
useEffect를 사용할 때, 특정 값이 변경 될 때만 호출하고 싶을때?
예를 들어, props 안에 들어있는 value 값이 바뀔때만 특정 작업을 수행.

배열 안에는 useState를 통해 관리하고 있는 상태를 넣어 주어도 되고,
props 전달받은 값을 넣어 주어도 됩니다.

8.2.3 뒷정리하기

useEffect 는 기본적으로 렌더링 되고 난 직후마다 실행되며,
두번째 파라미터 배열에 무엇을 넣는지에 따라 실행 조건 달라짐.
컴포넌트가 언마운트 되기 전이나 리렌더링 직전에 어떠한 작업 수행 하고싶다면
useEffect 에서 뒷정리 함수를 반환 해줘야 함.

8.3 useReducer

useReducer는 useState 보다 더 다양한 컴포넌트 상황에 따라
다른 값으로 업데이트 해주고싶을때 사용하는 Hook 입니다.

리듀서(Reducer) 의 개념은 17장 에서 리덕스를 배울 때 더 자세히.

리듀서는 현재 상태, 업데이트를 위해 필요한 정보를 담은 '액션' 값을 전달받아
새로운 상태를 반환하는 함수 입니다.
리듀서 함수에서 새로운 상태를 만들 때는 반드시 불변성 지켜줘야함.

useReducer 에서 사용하는 액션 객체는 반드시 type을 지닐 필요가 없다.
객체가 아니라 문자열 이나 숫자 여도 상관X

8.3.1 카운터 구현

Counter.js

useReducer 첫번째 파라미터 = reducer 함수.
			두번째 파라미터 = 해당 리듀서 기본값
			
사용하면 state 값과 dispatch 함수를 받아온다.
여기서 state는 현재 가리키고 있는 상태,
dispatch는 액션을 발생시키는 함수입니다.

dispatch(action) 과 같은 형태로, 함수안에 파라미터로 액션값 넣어주면,
리듀서 함수가 호출.

useReducer 의 가장 큰 장점은 컴포넌트 업데이트 로직을 컴포넌트 바깥으로 뺴낼수 있게된다.

8.3.2 인풋 상태 관리하기

useReducer를 사용하여 Info 컴포넌트 에서 인풋 상태를 관리해 보겠습니다.
기존에는 인풋이 여러개여서 useState를 여러번 사용.
useReducer 사용하면 기존에 클래스형 컴포넌트 에서 input 태그에 name 값 할당하고
e.target.name 참조하여 setState 를 해준 것과 유사한 방식 처리.
useReducer 에서의 액션은 어떤값도 사용 가능.
이벤트 객체가 지니고 있는 e.target값 자체를 액션 값으로 사용.
인풋의 갯수가 많아져도 간단히 해결.

8.4 useMemo

useMemo 는 컴포넌트 내부에서 발생하는 연산 최적화.
리스트에 숫자를 추가하면 추가된 숫자들의 평균을 보여주는 함수 컴포넌트 작성.

숫자를 등록할때 뿐만 아니라 인풋 내용이 수정될때도
getAverage 함수가 호출됨.
이렇게 렌더링 할때마다 계산하는것은 낭비다.

useMemo 를 사용하면 이런 작업 최적화.
렌더링 과정에서 특정값 바뀌었을 때만 연산을 실행, 원하는 값이 바뀌지 않았다면
이전에 연산했던 결과를 다시 사용.

8.5 useCallback
useMemo와 상당히 비슷한 함수. 주로 렌더링 성능 최적화 할때 사용.
만들어 놨던 함수를 재사용 할수 있다.

Average 컴포넌트는 onChange 와 onInsert 함수 선언.
이렇게 선언하면 컴포넌트가 리렌더링 될 때마다 새로 만들어진 함수를 사용하게 된다.
대부분의 경우 이러한 방식은 문제없지만, 컴포넌트 렌더링이 자주 발생하거나
렌더링 할 컴포넌트 개수가 많아지면 이부분을 최적화 해 주는것이 좋다.

useCallback의 첫 번째 파라미터에는 생성하고 싶은 함수를 넣고,
두번째 파라미터에는 배열.
이 배열에는 어떤 값이 바뀌었을 때 함수를 새로 생성하는지 명시해야 함.
빈 배열은 처음 렌더링 시에만 !

onChange 처럼 비어있는 배열을 넣게 되면 초기 렌더링시 만들었던 함수를
계속해서 재사용

onInsert 처럼 배열안에 number 와 list를 넣게 되면 인풋 내용이 바뀌거나
새로운 항목이 추가될 때 새로 만들어진 함수를 사용하게 됩니다.
( 새로 함수를 만드는 조건 ! )

함수 내부에서 state 값에 의존해야 할때는 그 값을 반드시 두번째 파라미터 안에 포함해야함 !
예를 들어 onChange 경우 기존의 값을 조회하지 않고 바로 설정만 하기 때문에
배열이 비어도 상관없지만,
onInsert 는 기존의 number와 list를 조회해서 nextList를 생성하기 때문에
배열 안에 number와 list를 꼭 넣어주어야 합니다.

8.6 useRef

useRef Hook 은 함수 컴포넌트에서 ref를 쉽게 사용할 수 있도록 해줍니다.
Average 컴포넌트 에서 등록 버튼을 눌렀을때 포커스가 인풋 쪽으로 넘어가도록 코드 작성.

useRef 를 사용하여 ref 설정시 useRef 를 통해 만든 객체 안의 current 값이
실제 엘리먼트를 가리킴.

8.6.1 로컬 변수 사용하기

컴포넌트 지역변수를 사용해야 할 때도 useRef를 활용할 수 있습니다.
여기서 로컬 변수란 렌더링과 상관없이 바뀔수 있는 값을 의미
ref 안의 값이 바뀌어도 컴포넌트가 렌더링 되지 않는다는 점에 주의.

8.7 커스텀 Hooks 만들기

여러 컴포넌트에서 비슷한 기능을 공유할 경우, 이를 여러분만의 Hook으로 작성하여
로직을 재사용 할수 있다.
기존에 Info 컴포넌트에서 여러 개의 인풋을 관리하기 위해 useReducer로 작성한 로직을
useInputs 라는 Hook으로 따로 분리.

8.8 다른 커스텀 hook

https://nikgraf.github.io/react-hooks/
https://github.com/rehooks/awesome-react-hooks


