6장 컴포넌트 반복

6.1 자바스크립트 배열의 map() 함수

코드가 복잡해지고 코드양이 늘어날수록, 파일용량도 증가하고 보여줄 데이터가 유동적이라면
반복되는 코드를 일일히 작성하는것은 관리가 불가능하다.
6장에서는 리액트 프로젝트에서 반복적인 내용을 효율적으로 보여주고 관리하는 방법 알아보자.

map 함수를 사용하여 반복되는 컴포넌트 렌더링
파라미터로 전달된 함수를 사용해서 배열내 각요소를 원하는 규칙에 따라 변환후
그 결과로 새로운 배열 생성.

arr.map(callback, [thisArg])

callback : 새로운 배열의 요소를 생성하는 함수. 세가지 파라미터.
	- currentValue	: 현재 처리하는 있는 element
	- index			: 현재 처리하고 있는 element의 index값
	- array			: 현재 처리하고 있는 원본 array
	
thisArg (선택 항목) : callback 함수 내부에서 사용할 this 레퍼런스

ex) 
var processed = numbers.map(function(num){
    return num * num;
});

6.2 데이터 배열을 컴포넌트 배열로 변환하기

6.3 Key

유동적인 데이터를 다룰때는 원소를 새로 생성할수도, 제거할 수도, 
수정할 수도 있다.
Key 가 없을때는 Virtual DOM을 비교하는 과정에서 리스트를 순차적으로 비교하면서
변화를 감지하지만,
Key가 있다면 어떤 변화가 일어났는지 더욱 빠르게 알아차린다.
Key는 컴포넌트 배열을 렌더링 했을때 어떤 원소에 변동이 있었는지 알아내려고 사용.

6.3.1 Key 설정

key 값을 설정할때는 map 함수의 인자로 전달되는 함수 내부에서 props 설정하듯.
key값은 언제나 unique 해야함. 데이터가 가진 고유값을 key 값으로,,

고유번호가 없는 경우?
map함수에 전달되는 콜백 함수의 인수인 index값을 사용.
고유한 값이 없을때만 index를 key로 사용해라.
index를 key로 사용하면 배열이 변경될떄 효율적인 렌더링 하지못한다.

6.4 응용

동적인 배열 렌더링 구현.
index값을 key로 쓰면 비효율적인데, 이런 상황에 어떻게 고유값 만드는가?

-1 초기상태 설정하기
-2 데이터 추가기능 구현하기
-3 데이터 제거기능 구현하기

6.4.1 초기상태 설정.

Iter 컴포넌트에서 useState 사용하여 상태 설정하기.
세가지 상태 : 데이터 배열, 텍스트 입력받기(input), 고유 id

객체 형태로 이루어진 배열 만들자. 해당 객체엔 문자열 + 고유 id 존재

6.4.2 데이터 추가기능 구현하기

ul 태그의 상단에 input 과 button 렌더링, input 상태 관리.

배열에 새항목 추가시 배열의 push()를 이용하지 않고 concat을 사용.
push는 기존 배열 자체를 변경, concat은 새로운 배열을 만들어준다.

리액트에서 상태를 업데이트 할때는 기존 상태를 그대로 두면서 새로운 값을 상태로 설정해야함.
-> 불변성 유지.
불변성 유지는 리액트 컴포넌트 성능 최적화의 핵심 !!!

onClick 함수에서 새로운 항목을 추가할때 객체의 id 값은 nextId 사용.
클릭될때마다 값이 1씩 올라간다. button 클릭시 기존 input 비우기 까지.

6.4.3 데이터 제거 기능 구현하기

각항목 더블클릭시 해당 항목 화면에서 사라지기.
불변성 유지 업데이트 사용. 이때는 filter 함수 사용.
함수 인자에 매개변수 만들어서 조건과 연산자로 가려냄.

HTML 요소를 더블클릭할때 이벤트는 onDoubleClick.
onRemove 함수 만들어서 li요소에 이벤트 등록.

6.5 정리

- 반복되는 데이터 렌더링
- 유동적인 배열.
- key값 설정. unique함 필수
- concat, filter 사용.

7장 컴포넌트의 라이프사이클 메서드

라이프사이클 ( 수명주기 ) 는 모든 리액트 컴포넌트에 존재.
컴포넌트의 수명은 페이지에 렌더링 되기 전인 준비과정 ~ 페이지 사라질때 끝남.

프로젝트 진행하다 보면 컴포넌트 처음 렌더링시 어떤 작업 처리나
컴포넌트 업데이트 하기 전후로 어떤 작업 처리 하거나, 불필요한 업데이트 방지 할떄도 있다.

이때는 라이프사이클 메서드 사용. 이것은 클래스형 컴포넌트만 사용.
Hooks 로 비슷한 작업을 할수있다. 8장에서 한다.

7.1장 라이프사이클 메서드의 이해

종류는 총 9가지.
Will : 어떤 작업 작동전 실행.
Did : 어떤 작업 작동후

이 메서드들은 컴포넌트 클래스 에서 덮어 써 선언.

라이프사이클 은 총 3가지 ( 마운트, 업데이트, 언마운트 ) 카테고리로 나눔.

마운트 : 페이지에 컴포넌트 나타남.
언마운트 : 페이지에서 컴포넌트 사라짐.
업데이트 : 컴포넌트 정보를 업데이트 ( 리렌더링 )

constructor : 컴포넌트 새로 만들떄마다 호출 ( 생성자 메서드 )
getDSFP : props 에 있는 값을 state에 넣을때
render : 우리가 준비한 ui 렌더링
componentDidMount : 컴포넌트가 웹 브라우저 상에 나타난후 호출 메서드

업데이트
컴포넌트는 4가지 경우에 업데이트
1. 부모 컴포넌트에서 넘겨주는 props가 바뀔떄
2. 컴포넌트 자신이 들고있는 state가 setState를 통해 바뀔때
3. 부모 컴포넌트 리렌더링 될때
4. this.forceUpdate로 강제 렌더링 트리거시

7.2 라이프사이클 메서드 살펴보기

7.2.1 render() 함수.

컴포넌트 모양새 정의. 유일한 필수 메서드.

이 메서드 안에서 props state 접근 할수 있으며, 리액트 요소 반환.
요소는 div 건 외부 컴포넌트 가 될수도 있다.
null, false를 반환 할수도 있다.

이 메서드 안에서는 이벤트 설정이 아닌곳에서 setState를 사용하면 안되며,
브라우저의 DOM에 접근도 안됨. DOM 정보를 가져오거나 state 변화는
componentDidMount 에서 처리.

8장 Hooks 

Hooks 는 함수 컴포넌트에서도 상태 관리 할수 있는 useState
렌더링 직후 작업을 설정하는 useEffect 등의 기능을 제공

8.2 useEffect

리액트 컴포넌트가 렌더링 될 때마다 특정 작업을 수행하도록 설정할 수 있는 Hook
componentDidMount 와 componentDidUpdate 를 합친 형태

8.2.1 마운트 될 때만 실행하고 싶을때

useEffect에서 설정한 함수를 컴포넌트가 화면에 맨처음 렌더링 될때만 실행하고,
업데이트 ( 리렌더링 ) 될때는 실행하지 않으려면 함수의 두번째 파라미터로 비어있는 배열
넣어주기. ex) , []

8.2.2 특정값이 업데이트 될 때만 실행하고 싶을때
useEffect를 사용할 때, 특정 값이 변경 될 때만 호출하고 싶을때?
예를 들어, props 안에 들어있는 value 값이 바뀔때만 특정 작업을 수행.

배열 안에는 useState를 통해 관리하고 있는 상태를 넣어 주어도 되고,
props 전달받은 값을 넣어 주어도 됩니다.

8.2.3 뒷정리하기

useEffect 는 기본적으로 렌더링 되고 난 직후마다 실행되며,
두번째 파라미터 배열에 무엇을 넣는지에 따라 실행 조건 달라짐.
컴포넌트가 언마운트 되기 전이나 리렌더링 직전에 어떠한 작업 수행 하고싶다면
useEffect 에서 뒷정리 함수를 반환 해줘야 함.

8.3 useReducer

useReducer는 useState 보다 더 다양한 컴포넌트 상황에 따라
다른 값으로 업데이트 해주고싶을때 사용하는 Hook 입니다.

리듀서(Reducer) 의 개념은 17장 에서 리덕스를 배울 때 더 자세히.

리듀서는 현재 상태, 업데이트를 위해 필요한 정보를 담은 '액션' 값을 전달받아
새로운 상태를 반환하는 함수 입니다.
리듀서 함수에서 새로운 상태를 만들 때는 반드시 불변성 지켜줘야함.

useReducer 에서 사용하는 액션 객체는 반드시 type을 지닐 필요가 없다.
객체가 아니라 문자열 이나 숫자 여도 상관X

8.3.1 카운터 구현

Counter.js

useReducer 첫번째 파라미터 = reducer 함수.
			두번째 파라미터 = 해당 리듀서 기본값
			
사용하면 state 값과 dispatch 함수를 받아온다.
여기서 state는 현재 가리키고 있는 상태,
dispatch는 액션을 발생시키는 함수입니다.

dispatch(action) 과 같은 형태로, 함수안에 파라미터로 액션값 넣어주면,
리듀서 함수가 호출.

useReducer 의 가장 큰 장점은 컴포넌트 업데이트 로직을 컴포넌트 바깥으로 뺴낼수 있게된다.

8.3.2 인풋 상태 관리하기

useReducer를 사용하여 Info 컴포넌트 에서 인풋 상태를 관리해 보겠습니다.
기존에는 인풋이 여러개여서 useState를 여러번 사용.
useReducer 사용하면 기존에 클래스형 컴포넌트 에서 input 태그에 name 값 할당하고
e.target.name 참조하여 setState 를 해준 것과 유사한 방식 처리.
useReducer 에서의 액션은 어떤값도 사용 가능.
이벤트 객체가 지니고 있는 e.target값 자체를 액션 값으로 사용.
인풋의 갯수가 많아져도 간단히 해결.

8.4 useMemo

useMemo 는 컴포넌트 내부에서 발생하는 연산 최적화.
리스트에 숫자를 추가하면 추가된 숫자들의 평균을 보여주는 함수 컴포넌트 작성.

숫자를 등록할때 뿐만 아니라 인풋 내용이 수정될때도
getAverage 함수가 호출됨.
이렇게 렌더링 할때마다 계산하는것은 낭비다.

useMemo 를 사용하면 이런 작업 최적화.
렌더링 과정에서 특정값 바뀌었을 때만 연산을 실행, 원하는 값이 바뀌지 않았다면
이전에 연산했던 결과를 다시 사용.

8.5 useCallback
useMemo와 상당히 비슷한 함수. 주로 렌더링 성능 최적화 할때 사용.
만들어 놨던 함수를 재사용 할수 있다.

Average 컴포넌트는 onChange 와 onInsert 함수 선언.
이렇게 선언하면 컴포넌트가 리렌더링 될 때마다 새로 만들어진 함수를 사용하게 된다.
대부분의 경우 이러한 방식은 문제없지만, 컴포넌트 렌더링이 자주 발생하거나
렌더링 할 컴포넌트 개수가 많아지면 이부분을 최적화 해 주는것이 좋다.

useCallback의 첫 번째 파라미터에는 생성하고 싶은 함수를 넣고,
두번째 파라미터에는 배열.
이 배열에는 어떤 값이 바뀌었을 때 함수를 새로 생성하는지 명시해야 함.
빈 배열은 처음 렌더링 시에만 !

onChange 처럼 비어있는 배열을 넣게 되면 초기 렌더링시 만들었던 함수를
계속해서 재사용

onInsert 처럼 배열안에 number 와 list를 넣게 되면 인풋 내용이 바뀌거나
새로운 항목이 추가될 때 새로 만들어진 함수를 사용하게 됩니다.
( 새로 함수를 만드는 조건 ! )

함수 내부에서 state 값에 의존해야 할때는 그 값을 반드시 두번째 파라미터 안에 포함해야함 !
예를 들어 onChange 경우 기존의 값을 조회하지 않고 바로 설정만 하기 때문에
배열이 비어도 상관없지만,
onInsert 는 기존의 number와 list를 조회해서 nextList를 생성하기 때문에
배열 안에 number와 list를 꼭 넣어주어야 합니다.

8.6 useRef

useRef Hook 은 함수 컴포넌트에서 ref를 쉽게 사용할 수 있도록 해줍니다.
Average 컴포넌트 에서 등록 버튼을 눌렀을때 포커스가 인풋 쪽으로 넘어가도록 코드 작성.

useRef 를 사용하여 ref 설정시 useRef 를 통해 만든 객체 안의 current 값이
실제 엘리먼트를 가리킴.

8.6.1 로컬 변수 사용하기

컴포넌트 지역변수를 사용해야 할 때도 useRef를 활용할 수 있습니다.
여기서 로컬 변수란 렌더링과 상관없이 바뀔수 있는 값을 의미
ref 안의 값이 바뀌어도 컴포넌트가 렌더링 되지 않는다는 점에 주의.

8.7 커스텀 Hooks 만들기

여러 컴포넌트에서 비슷한 기능을 공유할 경우, 이를 여러분만의 Hook으로 작성하여
로직을 재사용 할수 있다.
기존에 Info 컴포넌트에서 여러 개의 인풋을 관리하기 위해 useReducer로 작성한 로직을
useInputs 라는 Hook으로 따로 분리.

8.8 다른 커스텀 hook

https://nikgraf.github.io/react-hooks/
https://github.com/rehooks/awesome-react-hooks

9장 컴포넌트 스타일링

컴포넌트를 스타일링 하는 방식은 다양하지만, 여러 방식중 딱히 정해진 방식이 없다.
회사마다 요구하는 스펙이 다르고, 개발자마다 각자 취향에 따라 선택.
어떤 방식이 있는지 알아보고, 자주 사용하는 방식을 하나하나 사용해보자.

일반 css : 스타일링의 가장 기본적인 방식.
Sass : 자주 사용되는 css 전처리기 ( pre-processor ) 중 하나.
		확장된 css 문법을 사용하여 css 코드를 더욱 쉽게 작성.
CSS Module : 스타일을 작성할 때 CSS 클래스가 다른 CSS 클래스의 이름과
			절대 충돌하지 않도록 파일마다 고유한 이름을 자동으로 생성해주는
			옵션.
			
styled-components : 스타일을 JS 파일에 내장 시키는 방식.

CSS를 작성할때 가장 중요한 점은 CSS 클래스를 중복되지 않게 만드는 것.
css 클래스가 중복 되는것을 방지하는 여러가지 방식이 있는데,
그중 하나는 이름 지을때 특별한 규칙 (rule)을 사용하여 짓는것이고
다른 하나는 css Selectior 를 활용하는 것.

9.2.1 utils 함수 분리

여러 파일에서 사용될수 있는 Sass 변수 및 믹스인은 다른 파일로 따로 분리 작성.
필요한 곳에서 쉽게 불러와 사용.

styles 디렉터리 생성, 그안에 utils.scss 파일.
변수와 믹스인을 잘라내서 이동시키기.

9.2.2 sass-loader 설정 커스터마이징하기
Sass를 사용할때 반드시 해야하는것은 아니지만, 해두면 유용.
디렉터리가 많아서 구조가 깊어졌다면, 상위 폴더로 한참 거슬러 올라가야함.
이 문제점은 웹팩에서 Sass를 처리하는 sass-loader의 설정을 커스터마이징 하여 해결.

create-react-app 으로 만든 프로젝트는 프로젝트 구조의 복잡도를 낮추기위해
세부 설정이 모두 숨겨져 있다.
이를 커스터마이징 하려면 프로젝트 디렉터리 에서 yarn eject 명령어를 통해
세부설정을 밖으로 꺼내준다.

yarn eject는 아직 Git에 커밋되지 않은 변화가 있다면 진행되지 않는다.

Git 에 커밋하기.
https://evols-atirev.tistory.com/14

yarn eject 실행후 webpack.config.js 열기.
"sassRegex" 키워드 찾기
use: 밑에 'sass-loader' 지우고 .concat,,, 내용 집어넣기
설정 파일 저장후, 서버를 껐다가 재시작
@import 'utils.scss'; 로 경로 없이 사용가능.

새파일 생성시마다 매번 포함 시키기 힘드므로,
sass-loader의 additionalData 옵션 설정하기.
additionalData 는 sass 파일을 불러올 때 마다 코드 맨윗부분에 특정 코드를 포함시켜줌.

{
              test: sassRegex,
              exclude: sassModuleRegex,
              use: getStyleLoaders({
                importLoaders: 3,
                sourceMap: isEnvProduction
                  ? shouldUseSourceMap
                  : isEnvDevelopment,
              }).concat({
                loader: require.resolve("sass-loader"),
                options: {
                  sassOptions: {
                    includePaths: [paths.appSrc + "/styles"],
                  },
                  additionalData: `@import 'utils';`,
                },
              }),
              // Don't consider CSS imports dead code even if the
              // containing package claims to have no side effects.
              // Remove this when webpack adds a warning or an error for this.
              // See https://github.com/webpack/webpack/issues/6571
              sideEffects: true,
            },
			
이후 개발서버 재시작하고나면 모든 scss에서 utils.scss를 자동으로 불러옴.
sass 맨윗줄 import를 지워도 정상적으로 작동됨.

9.2.3 node_modules 에서 라이브러리 불러오기
Sass의 장점중 하나는 라이브러리를 쉽게 불러와서 사용할수 있다.
yarn을 통해 설치한 라이브러리를 사용하는 방법?
상대경로를 사용하여 node_modules 까지 들어가서 불러오는 방법이 기본적.
@import '../../../node_modules/library/styles';

하지만 깊숙한 디렉터리에서는 번거롭다. 더쉬운방법은
@import '~library/styles'; 이렇게 사용.

물결 문자를 사용하면 자동으로 node_modules 에서 라이브러리 디렉터리를 탐지하여
스타일을 불러올 수 있습니다.

Sass 라이브러리 두가지를 설치하고 사용해 보자

반응형 디자인을 쉽게 만들어 주는 include-media (https://include-media.com/)
매우 편리한 색상 팔레트 open-color(https://www.npmjs.com/package/open-color)

sass 라이브러리를 불러올 때는 node_modules 내부 라이브러리 경로 안에 들어있는
scss 파일을 불러와야함.
보통 scss 파일 경로가 어디에 위치하고 있는지를 라이브러리의 공식 매뉴얼에서
알려주지 않을 때가 많으니, 직접 경로로 들어가자.

include-media, open-color 사용하기.

SassComponent의 배경색을 open-color 팔레트 라이브러리에서 불러온후 설정,
화면 가로 크기가 768px 미만이 되면 배경을 어둡게

9.3 CSS Module

CSS Module은 CSS를 불러와서 사용할때 클래스 이름을 고유한 값,
[파일 이름]_[클래스 이름]_[해시값] 형태로 자동으로 만들어서 
컴포넌트 스타일 클래스 이름이 중첩되는 현상을 방지해 주는 기술.
CSS Module을 사용하기 위해 구버전(v1)의 create-react-app 에서는
웹팩에서 css-loader 설정을 별도로 해주어야 하지만,
v2 버전 이상부턴 따로 설정 없이 .module.css 확장자로 파일을 저장하기만하면
css module 이 적용됩니다.

CSSModule.module.css

CSS Module 을 사용하면 클래스 이름 지을때 그 고유성에 대해 고민 X
흔히 사용하는 단어로 이름을 짓는다고 해도 전혀 문제 X
해당 클래스는 우리가 방금 만든 스타일을 직접 불러온 컴포넌트 내부에서만 작동.

만약 특정 클래스가 웹 페이지에서 전역적으로 사용되는 경우라면 :global 앞에 입력하여
글로벌 CSS 임을 명시해 줄수 있습니다.

CSS Module 이 적용된 스타일 파일을 불러오면 객체를 하나 전달받게됨.
CSS Module 에서 사용한 클래스 이름과 해당 이름을 고유화한 키-값 형태를 받음.
예를 들어 console.log(styles)를 한다면 다음과 같은 결과.
{ wrapper: "CSSModule_wrapper__1SbdQ" }

지정한 클래스 이름 앞뒤로 파일이름, 해시값 붙음.

이 고유한 클래스 이름 사용하려면 클래스 적용할 JSX 엘리먼트에 
className={styles.[클래스이름]} 형태로 전달 해주면됨.
:global을 사용하여 전역적으로 선언한 클래스의 경우 평상시 해왔던 것처럼
그냥 문자열로 넣어줌.

CSS Module을 사용한 클래스 이름을 두개 이상 적용할때?
<div className={`${styles.wrapper} ${styles.inverted}`}>

ES6 문법인 Template Literal 을 사용하여 문자열 합함.
이 문법 사용하면 문자열 안에 자바스크립트 레퍼런스 쉽게 넣어줄수 있다.
`문자열 ${styleClass} 문자열`

CSSModule 클래스를 여러개 사용할때 템플릿 리터럴 문법을 사용하고 싶지 않다면 ?
<div className={[styles.wrapper, styles.inverted].join(' ')}>
== <div className={`${styles.wrapper} ${styles.inverted}`}>

9.3.1 classnames

classnames는 CSS 클래스를 조건부로 설정할때 유용한 라이브러리

CSS Module 을 사용할때 이 라이브러리 사용하면 여러 클래스 적용할때 매우편리.
파라미터를 조합해 CSS 클래스 설정 가능.
컴포넌트에서 조건부로 클래스를 설정할때 매우 편해짐.
예를 들어 props 값에 따른 스타일 주기가 쉬워진다

css 클래스상에서 조건을 걸어 놓기 때문에
컴포넌트에서 true나 false 를 받는 것으로 스타일을 조건부로 나타내기 쉬워진다.
-> 쓰지않는다면 컴포넌트에서 조건 연산자를 사용해야함 ? []:[]

CSS Module 도 사용이 훨씬 쉬워진다.
classnames 에 내장 되어있는 bind 함수를 사용하면 클래스를 넣어 줄때마다
styles.[클래스이름] 형태를 사용할 필요가 없다.
사전에 미리 styles 에서 받아온후 사용하게끔 설정후
cx('클래스이름', '클래스이름2') 형태로 사용할수 있다.

9.3.2 Sass 와 함께 사용하기

Sass를 사용할 때도 파일 이름 뒤에 .module.scss 확장자를 사용해주면
CSS Module 로 사용할 수 있습니다.

9.3.3 CSS Module이 아닌 파일에서 CSS Module 사용.

CSS Module 이 아닌 일반 .css / .scss 파일에서도
:local 을 사용하여 CSS Module 사용가능.

9.4 styled-components

컴포넌트 스타일링의 또 다른 패러다임은 자바스크립트 안에 스타일을 선언하는 방식.
이 방식을 'CSS-in-JS' 라고 불름.
https://github.com/MicheleBertoil/css-in-js 에서 확인.

이 절에서는 개발자들이 가장 선호하는 styled-components 알아보자.
이것을 사용하면 JS 파일 하나에 스타일까지 작성할수 있기 때문에
.css 또는 .scss 확장자를 가진 스타일파일을 따로 만들지 않아도 된다는 큰이점.

styled-components 라이브러리의 문법이 바뀐것 같으므로 패스.

10장 일정관리 웹 애플리케이션 만들기

이 장에서는 지금까지 배운 지식을 활용하여 일정관리 애플리케이션 만들기.

-1. 프로젝트 준비하기
-2. UI 구성하기
-3. 기능구현하기
