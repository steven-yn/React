23 JWT 를 통한 회원 인증 시스템 구현하기 

23.1 JWT 의 이해

이 장에서는 우리가 만든 서버에 회원 인증 시스템 구현.
이 시스템을 구현하기 위해 JWT 라는 기술을 사용.
JWT 는 JSON Web Token 의 약자로, JSON 으로 이뤄진 토큰을 의미.
두 개체가 서로 안전하게 정보를 주고받을수 있도록 웹 표준으로 정의된 기술.

23.1.1 세션 기반 인증과 토큰 기반 인증의 차이 

사용자의 로그인 상태를 서버에서 처리하는데 사용할수 있는
대표적인 두가지 인증 방식이 있다. 
하나는 세션을 기반으로 인증, 다른 하나는 토큰을 기반으로 인증.
두방식의 차이점을 알아보자.

23.1.1.1 세션 기반 인증 시스템 

세션을 기반을 인증 시스템을 만든다는 것은 어떤 의미일까?
한마디로 쉽게 설명하면, 서버가 사용자가 로그인 중 임을 기억하고 있다는 뜻.

세션 기반 인증 시스템에서 사용자가 로그인을 하면,
서버는 세션 저장소에 사용자의 정보를 조회하고 세션 id 를 발급.
발급된 id는 주로 브라우저의 쿠키에 저장함.
그 다음에 사용자가 다른 요청을 보낼 때 마다 서버는 세션저장소 에서 세션을 조회한후
로그인 여부를 결정하여 작업을 처리하고 응답을함.
세션 저장소는 주로 메모리, 디스크, DB 등을 사용.

세션 기반 인증의 단점은 서버를 확장하가 번거로워 질수 있다는 점.
만약 서버의 인스턴스가 여러개가 된다면, 모든 서버끼리 같은 세션을 공유해야 하므로
세션 전용 DB를 만들어야 할 뿐 아니라 신경써야 할것도 많다.

그렇다고 해서 세션 기반 인증이 무조건 좋지 않은것은 아니다.
잘 설계하면 충분히 좋은 시스템이 될 수 있다.

23.1.1.2 토큰 기반 인증 시스템

이번에는 토큰 기반 인증 시스템에 대해 알아보자.
토큰은 로그인 이후 서버가 만들어 주는 문자열이다.
해당 문자열 안에는 사용자의 로그인 정보가 들어있고,
해당 정보가 서버에서 발급되었음을 증명하는 서명이 들어있다.
서명 데이터는 해싱 알고리즘을 통해 만들어지는데, 주로 HMAC SHA256 또는 
RSA SHA256 알고리즘이 사용됨.

서버에서 만들어준 토큰은 서명이 있기 때문에 무결성이 보장됨.
무결성 이란 정보가 변경되거나 위조되지 않았음을 의미하는 성질.
사용자가 로그인을 하면 서버에서 사용자에게 해당 사용자의 정보를 지니고 있는
토큰을 발급해 주고, 추후 사용자가 다른 API를 요청하게 될떄
발급받은 토큰과 함께 요청하게 됨.
그러면 서버는 해당 토큰이 유효한지 검사하고, 결과에 따라 작업을 처리하고 응답함.

토큰 기반 인증 시스템의 장점은 서버에서 사용자 로그인 정보를 기억하기위해
사용하는 리소스가 적다는것. 사용자 쪽에서 로그인 상태를 지닌 토큰을 가지고 있으므로
서버의 확장성이 매우 높다.
서버의 인스턴스가 여러개로 늘어나도 서버끼리 사용자의 로그인 상태를
공유하고 있을 필요가 없다.

이 책에서는 두가지 시스템중 토큰 기반 인증 시스템 사용.
이 방식을 택한 이유는 인증 시스템을 구현하기 간편하고 사용자들의 인증 상태를 관리하기도
쉽기 때문이다.

실습 진행 순서
-1) User 스키마 / 모델 만들기 
-2) 회원 인증 API 만들기
-3) 토큰 발급 및 검증하기 
-4) posts API 에 회원 인증 시스템 도입하기 
-5) username/tags 로 포스트 필터링 하기.

User 스키마와 모델을 작성해 사용자의 정보를 MongoDB 에 담고 조회.
앞으로 만들 사용자 스키마에는 사용자 계정명과 비밀번호 필요.

비밀번호를 DB에 저장할때 플레인 ( 아무런 가공도 하지않은 ) 텍스트로 저장하면
보안상 매우 위험. 따라서 단방향 해싱 함수를 지원하는 bcrypt 라는 라이브러리 사용해
비밀번호 안전하게 저장.

해시를 만드는 함수와 해시를 검증하는 함수를 만들기 위해 bcrypt 설치.
yarn add bcrypt

23.2.1 모델 메서드 만들기 

모델 메서드는 모델에서 사용할 수 있는 함수를 의미하고, 두가지 종류가 있다.
첫번째는 인스턴스 메서드로, 모델을 통해 만든 문서 인스턴스 에서 사용할수 있는 함수를 의미.
( 인스턴스 내에서 사용하는 메서드 )
두번쨰는 스태틱 메서드로, 모델에서 바로 사용할수 있는 함수를 의미.
( 모델에서 사용하는 메서드 )

23.2.1.1 인스턴스 메서드 만들기 

우리는 두개의 인스턴스 메서드를 만들어 보겠다.
첫번째 메서드는 setPassword 이다.
이 메서드는 파라미터로 받은 비밀번호가 해당 계정의 비밀번호와 일치하는지 검증.

인스턴스 메서드를 작성할 땐 화살표 함수가 아닌 function 키워드를 사용해 구현.
함수 내부에서 this 에 접근해야 하기 때문.
여기서 this 는 문서 인스턴스를 가리킴. 화살표 함수를 사용하면 this 는 문서 인스턴스를
가라키지 못하게됨.

23.2.2 스태틱 메서드 만들기

findByUsername 이라는 스태틱 메서드 작성.
이 메서드는 username 으로 데이터를 찾을수 있게 해줌.

스태틱 함수의 this 는 모델을 가리킴. 지금 여기선 User 를 가리킨다.

23.3 회원 인증 API 만들기 

먼저 새로운 라우트를 정의. api 디렉터리에 auth 디렉터리를 생성하고
그안에 auth.ctrl.js 작성.

이번 라우트에서 총 4개의 API 만듦. 이렇게 함수의 틀만 잡아주고,
auth 디렉터리에 index.js 파일을 만들어서 auth 라우터 생성.

api 디렉터리에 index.js 안에 auth 라우터를 api 라우터에 적용.

이렇게 3개의 파일이 준비가 되면, API 라우트 구조가 완성.

23.3.1 회원가입 구현하기.

register API 작성.

회원가입 시 중복되는 계정 생성되지 않도록 기존에 해당 username 이 존재하는지 확인.
-> findByUsername 스태틱 메서드를 이용해 처리.
비밀번호 설정하는 과정에서는 setPassword 인스턴스 함수 사용.
( 스태틱은 js 내에서 DB에서 값을 받아 내가 쓸라고 만든 함수,
인스턴스는 DB로 값을 입력할때 쓸려고 만든 함수임을 알수있음 )

이렇게 스태틱 또는 인스턴스 함수에서 하는 작업들은 이 API 함수 내부에서
직접 구현해도 상관없지만, 이렇게 메서드를 따로 만들면 가독성도 좋고
추후 유지보수시에 도움이 됨.

함수의 마지막 부분에서는 hashedPassword 필드가 응답되지 않도록
데이터를 JSON 으로 변환후 delete 를 통해 해당 필드를 지워줌.
앞으로 비슷한 작업을 많이한다. 따라서 이 작업을 serialize 라는
인스턴스 함수로 따로 만들어 주자.

이 API 잘 작동하는가 postman 으로 확인.

23.3.2 로그인 구현하기 

이 API 에서는 username, password 값이 제대로 전달되지 않으면 에러로 처리.
그리고 findByUsername 을 통해 사용자 데이터를 찾고, 만약
사용자 데이터가 없으면 역시 에러로 처리.
계정이 유효 하다면 checkPassword 를 통해 비밀번호를 검사하고
성공시 계정정보 응답.

코드를 다 작성했다면 postman 으로 요청.

23.4 토큰 발급 및 검증하기 

이제 클라이언트 에서 사용자 로그인 정보를 지니고 있을 수 있도록 
서버에서 토큰을 발급. JWT 토큰을 만들기 위해서는 jsonwebtoken 모듈 설치.

yarn add jsonwebtoken

23.4.1 비밀키 설정.

.env 파일을 열어서 JWT 토큰을 만들때 사용할 비밀키 만듬.
이 비밀키는 문자열로 아무거나 입력.

JWT_SECRET=13524632586u5389gnefjgnethjtb34thf2h238ehfsdfsd

이 비밀키는 나중에 JWT 토큰의 서명을 만드는 과정에서 사용.
비밀키는 외부에 공개되면 절대로 안됨. 
비밀키가 공개되는 순간, 누구든지 마음대로 JWT 토큰을 발급.

23.4.2 토큰 발급하기.

비밀키를 설정했으면 user 모델 파일에서 generateToken 이라는 인스턴스 메서드 생성.

이제 회원가입과 로그인에 성공했을 때 토큰을 사용자에게 전달.
사용자가 브라우저에서 토큰을 사용할땐 주로 두가지 방법 사용.
첫번째는 브라우저의 localStorage 혹은 sessionStorage 에 담아서 사용하는 방법,
두번쨰는 브라우저의 쿠키에 담아서 사용하는 방법.

브라우저의 localStorage 혹은 sessionStorage 에 토큰을 담으면 
사용하기가 매우 편리하고 구현하기도 쉽다. 하지만 만약 누군가가 페이지에
악성 스크립트를 삽입한다면 쉽게 토큰을 탈취할수 있다.
( 이러한 공격을 XSS : Cross Site Scripting 이라고 부른다. )

쿠키에 담아도 같은 문제가 발생할 수 있지만, httpOnly 라는 속성을 활성화 하면
JS 를 통해 쿠키를 조회할 수 없으므로 악성 스크립트로 부터 안전.
그 대신 CSRF : Cross Site Request Forgery 라는 공격에 취약해질수 있다. 
이 공격은 토큰을 쿠키에 담으면 사용자가 서버로 요청을 할 때 마다 무조건 토큰이
함께 전달되는 점을 이용해 사용자가 모르게 원하지 않는 API 요청을 하게 만듬.

예를 들어 사용자가 자신도 모르는 상황에서 어떠한 글을 작성하거나, 삭제하거나,
또는 탈퇴하게 만들수도 있다.

단, CSRF 는 CSRF 토큰 사용및 Referer 검증등의 방식으로 제대로 막을수 잇는 반면,
XSS 는 보안장치를 적용해도 개발자가 놓칠수 있는 다양한 취약점을 통해 공격 받을수 있다.

이 책에서는 사용자 토큰을 쿠키에 담아 사용. register 와 login API 를 수정.

23.4.3 토큰 검증하기 

이번에는 사용자의 토큰을 확인한 후 검증하는 작업.
이 작업은 미들웨어를 통해 처리.

src/lib 디렉터리를 만들고, 그안에 jwtMiddleware.js 라는 파일을 생성.

미들웨어를 만든뒤 main.js 에서 app 에 미들웨어를 적용.
jwtMiddleware 를 적용하는 작업은 app 에 router 미들웨어를 
적용하기 전에 이뤄져야 함.

postman 으로 check 경로로 GET 요청하고, 터미널확인
나타나지 않는다면 로그인 API 를 성공적으로 호출하고서 다시해보기.
현재 토큰이 해석된 결과가 나타남.

이렇게 해석된 결과를 이후 미들웨어 에서 사용하려면 ctx 의 state 안에 넣어줌.

콘솔에 토큰 정보를 출력하는 코드는 이후 토큰이 만료되기전에
재발급 해주는 기능을 구현후에 지움.

23.4.4 토큰 재발급하기

jwtMiddleware 를 통해 토큰이 해석된 이후 다음과 같은 결과물이 출력되고 있다.
{
  _id: '618fe2f52b27622fcf1425a4',
  username: 'steven',
  iat: 1636822358,
  exp: 1637427158
}

여기서 iat 는 이 토큰이 언제 만들어쪗는지 알려주는 값,
exp 는 언제 만료되는지 알려주는 값.

exp 에 표현된 날짜가 3.5일 미만이라면 토큰을 새로 재발급 해주는 기능 구현.

토큰 재발급이 잘되는지 확인해 보고 싶다면 user 모델 파일의
generateToken 함수에서 토큰 유효 기간을 2일로 설정하고, 다시 login API 를 
요청한다음 check API 를 요청해보자. 토큰 재발급이 잘 이뤄지면, check API 를 
요청할때 Headers 에서 새 토큰이 Cookie 를 통해 설정된다.

23.4.5 로그아웃 기능 구현.

마지막 회원 인증 관련 API 인 로그아웃 기능 구현.
이 API 는 쿠키를 지워주기만 하면 끝남.

access_token 이 비워지는 Set-Cookie 헤더가 나타나고 204 에러가 뜸.



