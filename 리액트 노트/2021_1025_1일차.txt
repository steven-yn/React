리액트를 다루는 기술.

- 개요
대규모 어플리케이션중 프론트엔드 사이드에서 돌아가는 어플리케이션 구조를
관리하려면 어떻게 해야할까요? 솔직히 이런 어플을 특별한 도구없이
순수하게 자바스크립트로만 관리하려면 골치 아프겠죠?
지금까지 수많은 프레임 워크가 조금씩 다른 관점에서 이를 해결하려고 노력해왔습니다.
Angular, Backbone, Derby, Ember, Ext, Knockback, Sammy, PureMVC,
Vue 등.
프레임워크들은 주로 MVC 아키텍처, MVVM, 아키텍처를 사용합니다.
Angular의 경우에는 MVW 아키텍처로 어플을 구조화 하죠.
MVC, MVVM, MVW 등과 같은 여러구조가 지닌 공통점은 모델과 뷰가 있다는 것.

모델은 어플리케이션에서 사용하는 데이터를 관리하는 영역이고,
뷰는 사용자에게 보이는 부분입니다.
컨트롤러는 프로그램이 사용자에게서 어떤 작업을 받으면 모델 데이터를 조회하거나
수정하고, 변경된 사항을 뷰에 반영합니다.

반영하는 과정에서 보통 뷰를 변형(mutate) 하지요. 

어떤 데이터가 변할때마다 어떤 변화를 줄지 고민하는것이 아닌,
기존 뷰를 날려버리고 처음부터 새로 렌더링 하는 방식입니다.
이렇게 하면 어플 구조가 매우 간단하고, 작성할 코드양도 많이 줄어듭니다.
더이상 어떻게 변화를 줄지 신경 쓸 필요가 없고, 그저 뷰가 어떻게 생길지
선언하며, 데이터에 변화가 있으면 기존에 있던 것은 버리고 정해진 규칙에 따라
새로 렌더링 하면 되니까요.

1.1.1 리액트 이해

리액트는 자바스크립트 라이브러리로 사용자 인터페이스를 만드는데 사용합니다.
오직 V(View)만 신경쓰는 라이브러리 입니다.
리액트 프로젝트에서 특정 부분이 어떻게 생길지 정하는 선언체가 있는데,
이를 컴포넌트 라고 합니다.
컴포넌트는 템플릿과는 다른 개념입니다.
템플릿은 보통 데이터셋이 주어지면 HTML 태그형식을 문자열로 반환하는데,
컴포넌트는 이와 달리 좀더 복합적인 개념입니다.
컴포넌트는 재사용이 가능한 API로 수많은 기능들을 내장하고 있으며,
컴포넌트 하나에서 해당 컴포넌트의 생김새와 작동 방식을 정의합니다.

렌더링 : 사용자 화면에 뷰를 보여주는것.

리액트 컴포넌트가 최초로 실행한 ' 초기렌더링 '과
컴포넌트의 데이터 변경으로 다시 실행되는 ' 리렌더링 ' 개념을 이해 해야함.

1.1.1.1 초기 렌더링

어떤 프레임워크, 라이브러리를 사용하던지간에 맨처음 어떻게 보일지 정하는
초기렌더링이 필요하다.

render() 함수

이 함수는 컴포넌트가 어떻게 생겼는지 정의하는 역할.
html 형식의 문자열을 반환하지 않고, 뷰가 어떻게 생겼고 어떻게 작동하는지에
대한 정보를 지닌 객체를 반환.
컴포넌트 내부에는 또 다른 컴포넌트들이 들어갈수 있습니다.
이때 render 함수를 실행하면 그 내부에 있는 컴포넌트들도 재귀적으로 렌더링.
이렇게 최상위 컴포넌트의 렌더링 작업이 끝나면 지니고 있는 정보들을 사용하여
HTML 마크업을 만들고, 이를 우리가 정하는 실제페이지의 DOM 요소안에 주입.

컴포넌트를 실제 페이지에 렌더링 할때는 분리된 두가지 절차를 따름.
문자열 형태의 HTML 코드를 생성한후 특정 DOM에 해당 내용을 주입하면 이벤트가 적용됩니다.

1.1.1.2 조화과정

업데이트를 어떻게 진행하는가?
리액트에서 뷰를 업데이트 할때는 " 업데이트 과정을 거친다 " 라기보다는
" 조화 과정 ( reconciliation ) 을 거친다 " 라고 하는것이 더 정확한 표현.
컴포넌트에서 데이터에 변화가 있을때 우리가 보기에는 변화에 따라 뷰가 변형 되는
것처럼 보이지만, 사실은 새로운 요소로 갈아 끼운다.
이 작업 또한 render 함수가 맡아서 한다.
컴포넌트는 데이터를 업데이트 했을때 단순히 업데이트한 값을 수정하는것이 아닌,
새로운 데이터를 가지고 render 함수를 다시 호출합니다.
그러면 그 데이터를 지닌 뷰를 생성해 내겠죠?

하지만 이때 곧바로 DOM에 반영하지 않고, 이전에 render 함수가 만들었던
컴포넌트 정보와 현재 render 함수가 만든 컴포넌트 정보를 비교합니다.

자바스크립트를 사용하여 두가지 뷰를 최소한의 연산으로 비교후, 둘의 차이를 알아내
최소한의 연산으로 DOM 트리를 업데이트한다.

결국 방식 자체는 루트 노드부터 시작하여 전체 컴포넌트를 다시 렌더링 하는것 처럼 보이지만,
사실 최적의 자원을 사용하여 이를 수행.

1.2 리액트의 특징

1.2.1 Virtual DOM

1.2.1.1 DOM 이란?

DOM ( Document Object Model ) 의 약어.
객체로 문서 구조를 표현하는 방법으로, XML / HTML 로 작성.

웹 브라우저는 DOM을 활용하여 객체에 자바스크립트와 CSS를 적용한다.
DOM은 트리 형태라서 특정 노드를 마음대로 사용가능.

DOM은 과연 느릴까요?
DOM API를 수많은 곳에 사용하는데, 이 DOM에는 치명적인 한가지 문제점이 있다.
바로 동적 UI ( Dynamic ) 에 최적화 되어있지 않다는 것.
html 자체는 정적이고, 자바스크립트를 사용하여 이를 동적으로 만듬.

큰 규모의 웹 어플, 트위터나 페이스북 생각해보자.
스크롤바를 내릴수록 수많은 데이터 로딩.
각 데이터를 표현하는 요소들이 있꼣죠.
요소 개수가 몇백개, 몇천개 단위로 많다면 ( 페북에서 포스트 한개를 표현할때 사용하는
<div> 요소 개수는 약 100개 ) 이야기는 달라진다.
이런 규모가 큰 웹 어플에서 DOM에 직접 접근하여 변화를 주다보면
성능 이슈가 조금씩 발생하기 시작.

DOM 자체는 빠르다.
단, 웹 브라우저 단에서 DOM에 변화가 일어나면 웹 브라우저가 CSS를 다시 연산하고,
레이아웃을 구성하고, 페이지를 리페인트 한다. 이 과정에서 시간이 허비되는것.

해결법
HTML 마크업을 시각적인 형태로 변환하는것은 웹 브라우저가 하는 주 역할,
이를 처리할때 자원을 사용하는것은 어쩔수 없다.
DOM을 조작할 때 마다 엔진이 웹 페이지를 새로 그리기 때문에 업데이트가 너무 잦으면
성능이 저하될수 있다.
-> DOM을 최소한으로 조작하여 작업을 처리하는 방식으로 개선할수 있다.

리액트는 Virtual DOM 방식을 사용해 DOM 업데이트를 추상화 함으로써
DOM 처리 횟수를 최소화하고 효율적으로 진행.

1.2.1.2 Virtual DOM

실제 DOM에 접근하여 조작하는 대신, 이를 추상화한 자바스크립트 객체를 구성하여
사용합니다. 마치 실제 DOM의 가벼운 사본과 비슷.

리액트에서 데이터가 변하여 웹 브라우저에 실제 DOM을 업데이트 할때는 
세가지 절차를 밟는다.

1. 데이터를 업데이트 하면 전체 UI를 Virtual DOM에 리렌더링 한다.
2. 이전 Virtual DOM에 있던 내용과 현재 내용을 비교.
3. 바뀐 부분만 실제 DOM에 적용.

우리는 다음 문제를 해결하려고 리액트를 만들었습니다.
지속적으로 데이터가 변화하는 대규모 어플 구축하기

Virtual DOM 은 무조건적인 빠른 것은 아니다.
업데이트 처리 간결성이 장점.

1.2.2 기타특징

일부 웹 프레임워크가 MVC 또는 MVW 등의 구조를 지향하는것과 달리 리액트는
오직 뷰만 담당.
리액트는 프레임워크가 아닌 라이브러리.
다른 웹 프레임워크가 Ajax, 데이터 모델링, 라우팅등과 같은 기능을 내장하는 반면,
리액트는 정말 뷰만 신경쓰는 라이브러리로 기타기능은 직접 구현해야함.

다른 개발자들이 만든 라이브러리, 즉 라우팅에는 리액트 라우터,
Ajax 처리에는 axios나 fetch, 상태관리에는 리덕스나 MobX를 사용하여
빈 자리를 채운다.
해당 분야에서 마음에 드는 라이브러리를 사용하면 되니까 자신의 취향대로 스택을
설정할수 있다는 장점이 있지만, 여러 라이브러리를 접해야한다는 단점도 있다.

또 리액트는 다른 웹 프레임워크나 라이브러리와 혼용할수도 있다.
백본, 앵귤러등의 프레임워크 함께 언제든 사용가능.

1.3 작업 환경 설정.

- Node.js / npm, yarn 설치
- 코드 에디터 설치
- Git 설치
- create-react-app으로 프로젝트 만들기.

1.3.1 Node.js와 npm

Node.js는 크롬 V8 자바스크립트 엔진으로 빌드한 자바스크립트 런타임 입니다.
이것으로 웹 브라우저 환경이 아니더라도 js를 사용하여 연산할수 있다.
2009년 출시이후 js는 모든곳에서 엄청나게 활약할수 있게 되었다.
리액트는 웹 브라우저에서 실행되는 코드이므로 노드js와 직접적인 연관은 없지만,
프로젝트 개발에 필요한 주요 도구들이 노드 js를 사용.

사용하는 개발도구:
	바벨 ( babel ) = ECMAScript 6 ( 2015 공식 JS 문법 ) 를 호환 시켜줌. 
	웹팩 = 모듈화된 코드를 한 파일로 합치고 ( 번들링 ) 코드를 수정할 때 마다 웹
			브라우저를 리로딩 하는 등 여러 기능 지님.
			책 후반부는 노드js를 사용해 백엔드 서버도 구현함.
			
노드js를 설치하면 노드js 패키지 매니저 도구인 npm이 설치됨.
npm으로 패키지 ( 재사용 가능 코드 ) 를 설치하고 설치한 패키지의 버전을
관리할수 있다. 리액트 역시 하나의 패키지.
현재 npm 저장소에 등록된 패키지는 약 82만개로, 하루 평균 475개의 패키지가
새로 등록.

1.3.1.1 설치


2.1 코드 이해하기

리액트로 만든 프로젝트의 JS 파일에서는 import를 사용하여 다른 파일들을 불러와
사용할수 있습니다.

이렇게 모듈을 불러와 사용하는것은 원래 브라우저에는 없던 기능.
브라우저가 아닌 환경에서 JS를 실행할수 있게 해주는 환경인 Node.js에서 지원하는 기능.
노드js 에서는 import가 아닌 require라는 구문으로 패키지를 불러올수 있다.

이러한 기능을 브라우저에서도 사용하기위해 번들러 ( bundler ) 사용.
파일을 묶듯이 연결하는 것.

번들러 (웹팩) 을 사용하면 import로 모듈을 불러왔을때 불러온 모듈을 모두 합쳐서
하나의 파일을 생성해준다. 최적화 과정에서 여러개의 파일로 분리될 수도 있다.

src/index.js를 시작으로 필요한 파일을 다 불러와서 번들링.

2017년 부터는 브라우저에서도 import 구문을 사용할수 있게 되었지만,
이는 단순히 다른 경로에 있는 JS를 불러오는 용도로만 사용되기 때문에 번들링과는 다름.

웹팩을 사용하면 SVG 파일과 CSS 파일도 불러와서 사용가능.
이런 기능은 웹팩의 로더(loader)라는 기능이 담당.
css-loader는 css 파일을 불러올수 있게 해주고,
file-loader는 웹 폰트나 미디어 파일등을 불러올수 있게 해줍니다.
babel-loader는 JS 파일들을 불러오면서 최신 JS 문법으로 작성된 코드를
바벨이라는 도구를 사용하여 ES5 문법으로 변환 해줍니다.

*
 ES5 는 이전버전의 JS를 의미.
최신 JS 문법을 ES5 형태로 변환하는것은 구버전 웹 브라우저와 호환하기 위함.
리액트 컴포넌트에서 사용하는 JSX라는 문법도 정식 JS 문법이 아니므로 ES5형태의
코드로 변환해야 합니다.
ES5 이후의 문법들은 ECMAScript 2015 (ES6), ECMAScript 2016 (ES7)
같은 형태.

웹팩의 로더는 원래 직접 설치하고 설정해야하지만 리액트 프로젝트를 만들때 사용했던
create-react-app이 번거로운 작업을 모두 대신해주기 때문에
우리는 별도의 설정을 할필요가 없다.
이 설정을 커스터마이징 하는것은 나중에 설명.

코드의 간단한 이해

function 키워드를 사용하여 만들어진 App 이라는 컴포넌트를
함수 컴포넌트 라고 부른다.

2.2 JSX 란?

JSX는 JS의 확장문법.
XML과 매우 유사.
브라우저에서 실행되 전 코드 번들링 과정에서 바벨을 사용하여
일반 JS 형태 코드로 변환됨.

2.3.2 더욱 높은 활용도
JSX 에서는 친숙한 HTML 태그와 앞으로 만들 컴포넌트도
JSX안에서 작성할 수 있다. App.js 에서는 App 컴포넌트가 만들어졌지요?
src/index.js 파일을 열어보면 이 App 컴포넌트를 마치 HTML 태그 쓰듯
그냥 작성한다.

2.4.1 감싸인 요소

컴포넌트에 여러 요소가 있다면 반드시 부모 요소 하나로 감싸야 한다.
상단에 SVG와 CSS import 구분을 지우고 App.js 파일을 변경 해보자.

요소 여러개가 부모 요소 하나에 의해 감싸져 있지 않기 때문에 오류 발생. (div 컨테이너가 없음)

Virtual DOM 에서 컴포넌트 변화를 감지해낼때 효율적으로 비교할수 있게
컴포넌트 내부는 하나의 DOM 트리구조로 이루어져야한다는 규칙이 있다.

만약 div 요소 없이 바로 나타 내고싶다면 Fragment 기능을 사용.
<> ~ </> 만으로 나타낼수있다!!

JSX 안에서는 JS 표현식을 쓸수 있다.
JSX 내부에서 코드를 { } 로 감싸면 된다.

ES6 문법
const는 상수를 선언할때 사용하는 키워드입니다.
let은 동적인 값을 담을수 있는 변수 선언.
ES6 이전에는 값을 담는데 var 사용. 
var은 scope( 해당값을 사용할수 있는 코드영역) 가 함수단위.
let 과 const 는 scope가 함수단위가 아닌 블록단위.

if문 내부에서 선언한 a 값은 if문 밖의 a 값을 변경하지 않음.
let과 const를 사용할때 같은 블록 내부에서 중복 선언이 불가능하다.
const는 한번 선언하면 재설정 불가.

2.4.3 if문 대신 조건부 연산자 (삼항 연산자)

JSX 내부의 JS 표현식에서 if문 사용할수는 없다.
하지만 조건에 따라 다른 내용을 렌더링 해야할때는 JSX 밖에서 if문 사용하여
사전에 값을 설정하거나, { } 안에 조건부 연산자를 사용하면 됨.

return { [조건문] ? ( [true출력] ) : ( [false출력] ) }

2.4.4 AND 연산자 (&&) 를 사용한 조건부 렌더링
특정 조건을 만족할때 내용을 보여주고, 만족하지 않을때 아무것도 렌더링 하지
않아야할때..

return { [조건문] && ( [true출력] ) }

단, null과 비슷한 출력인 0 은 예외적으로 화면에 나타난다.

* JSX를 괄호로 감싸는 것은 필수사항이 아니다.

2.4.5 undefined 를 렌더링 하지 않기

return [undefined 개체] || [undefined일경우 출력할 개체];
return <div>{[출력개체1(undefined)] || [출력개체2]}</div>
-- 위의경우 출력개체2 가 출력됨.

어떤값이 undefined 일수도 있다면, OR (||) 연산자를 사용하면 해당값이
undefined 일때 사용할 값을 지정할 수 있으므로 간단하게 오류 방지.
JSX 내부에서 undefined 렌더링은 괜찮다.

2.4.6 인라인 스타일링
리액트에서 DOM 요소에 스타일을 적용할때는 문자열 형태로 넣는 것이
아니라 객체 형태로 넣어주어야 한다. (카멜표기법 사용)
ex) background-color ==> backgroundColor

2.4.7 class 대신 className ( 외부 스타일시트 )

일반 HTML 에서 css 클래스를 사용할때는 
<div class ="myclass"></div>와 같이 class 라는 속성을 설정.
하지만 JSX에서는 class가 아닌 className으로 설정.
우선 src 디렉터리 안에 있는 App.css 다지우고 새 css클래스 작성.

기존 App 컴포넌트에서 인라인 스타일에 사용한 폰트 색상과 배경색을
뒤바꾼 스타일.
App.js 파일에서 상단에 App.css 를 불러온뒤 div 요소에 className값 지정.

JSX 작성할때 CSS 클래스를 설정하는 과정에서 className 대신 class 로 입력해도
스타일이 적용되기는 한다. 하지만 브라우저 Console 탭에 경고를 띄운다.
이전 버전에서는 css클래스가 적용되지 않았는데, 리액트 v16부터는
class를 className 으로 변환시켜 주고 경고를 띄움.

2.4.8 꼭 닫아야 하는 태그.
HTML 코드를 작성할때 <input> 같은 요소는 닫지않아도 작동.
하지만 JSX에서는 태그를 닫지 않으면 오류가 발생 !
따라서 태그사이에 별도의 내용이 들어가지 않는경우 ( br, input )
<input /> 처럼 표기해 사용. <-- self-closing 태그 라고함.

2.4.9 주석
JSX 안에서 주석을 작성하는 방법?
{/**/}

2.5 ESLint 와 Prettier 적용하기

2.5.1 ESLint
ESLint는 문법 검사도구, Prettier는 코드 스타일 자동정리 도구.
ESLint는 코드 작성시 실수하면 에러 혹은 경고 메시지를 VSC 에서 바로 확인하게 해줌.
예를들어 주석을 잘못 입력해서 화면에 그대로 나오고 있는경우 ..

2.5.2 Prettier
JSX를 작성할때는 코드의 가독성을 위해 들여쓰기 사용.
들여쓰기가 제대로 되어있지 않은 코드는 읽기가 매우 힘들기 때문.
