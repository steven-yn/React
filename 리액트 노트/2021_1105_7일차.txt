15장 Context API

Context API는 리액트에서 전역적으로 사용할 데이터가 있을때 유용한 기능.
사용자 로그인 정보, 애플리케이션 환경 설정, 테마 등 여러종류.
Context API는 v16.3 부터 사용하기 쉽게 개선되었다.
이 기능은 리액트 관련 라이브러리 에서도 많이 사용.
예를 들어 리덕스, 리액트 라우터, styled-components 등의 라이브러리는
Context API 기반이다.

실습 진행순서

-1) Context API 를 사용한 전역 상태 관리 흐름 이해
-2) 기본적인 사용법 익히기
-3) 동적 Context 사용하기.
-4) Consumer 대신 Hook 또는 static contextType 사용.

15.1 Context API 를 사용한 전역 상태관리 흐름 이해.

프로젝트 내 환경설정, 사용자 정보 같은 전역적 상태를 관리 해야할 떈?
리액트 애플리케이션은 컴포넌트 간에 데이터를 props 로 전달하기 때문에
컴포넌트 여기저기서 필요한 데이터가 있을 때는 주로 최상위 컴포넌트인
App 의 state에 넣어서 관리.

App에서 데이터를 최하위 컴포넌트 에게 전달하려면
상당히 복잡하게 여러번 거쳐서 전달해야한다.

실제 리액트 프로젝트 에서는 더 많은 컴포넌트 를 거칠때도 있고,
다루어야 하는 데이터가 훨씬 많아질 수도 있으므로, 이런방식을 사용하면
유지 보수성이 낮아질 가능성이 있다.

그렇기 때문에 리덕스나 MobX 같은 상태 관리 라이브러리를 사용하여
전역 상태 관리 작업을 더 편히 처리함.
v16.3 이후는 Context API가 많이 개선되어서 별도 라이브러리 사용하지 않아도
쉽게 관리 가능.

여러 컴포넌트 거치는 props 전달 대신, Context API 를 사용하면
Context 를 만들어 단한번에 원하는 값을 받아와 사용한다.

15.2 Context API 사용법 익히기.

15.2.1 새 Context 만들기

프로젝트 생성후, 새로운 Context 만들자.
src 디렉터리에 contexts 디렉터리 만들고 그안에 color.js
Context 만들때 반드시 contexts 디렉터리 만들 필요없다.

새 Context 만들때는 createContext 함수사용.

15.2.2 Consumer 사용하기.

이번에는 ColorBox 컴포넌트 만들어 ColorContext 안에 들은 색상 보여주기.
색상을 props로 받아오는 것이 아닌 ColorContext 안에 들은
Consumer 라는 컴포넌트 통해 색상 조회.

Consumer 사이에 중괄호를 열어 그안에 함수 넣어주었다.
이러한 패턴을 Function as a child, 또는 Render Props 라고함.
컴포넌트의 children 이 있어야 할 자리에 일반 JSX 혹은 문자열이
아닌 함수 전달.

15.2.3 Provider

Provider 사용시 Context 의 value 변경 가능.

기존에 createContext 함수 사용할땐 파라미터로 Context의 기본값 넣었다.
이 기본값은 Provider 미사용시 사용됨. 만약 Provider 는 사용했지만
value를 명시하지 않았다면, 이 기본값을 사용하지 않아서 오류 발생.

15.3 동적 Context 사용하기

지금 까지 내용으로는 고정적인 값만 사용.
Context 값을 업데이트 해야하는 경우 어떻게 해야할까?

15.3.1 Context 파일 수정

Context value 에는 무조건 상태값만 있어야 하는것은 아니다.
함수를 전달해 줄수도 있다! ( props 처럼 )

기존에 작성했던 ColorContext 의 코드를 수정.

ColorProvider 라는 컴포넌트 새로 작성.
그 컴포넌트 안에 ColorContext.Provider 렌더링 함.
이 Provider 의 value 에는 상태는 state로,
업데이트 함수는 actions로 묶어 전달.

Context 에서 값을 동적으로 사용할 때 반드시 묶어줄 필요는 없지만,
이렇게 state와 actions 객체를 따로 분리해두면 나중에 다른 컴포넌트
에서 Context 값 사용시 편리.

추가로 createContext 사용시 기본값으로 사용할 객체도 수정.
createContext 의 기본값은 실제 Provider 의 value 에 넣는
객체의 형태와 일치시켜주는것이 좋다.
그렇게 하면 Context 코드를 볼때 내부 값이 어떻게 구성되어 있는지
파악하기도 쉽고, 실수로 Provider 를 사용하지 않을때
리액트 애플리케이션 에서 에러 발생하지 않는다.

15.3.2 새로워진 Context 를 프로젝트에 반영하기.

App에 ColorProvider 적용하고, ColorBox 도 ColorConsumer 변경.
사용할 value 형태도 반영.

15.3.3 색상 선택 컴포넌트 만들기.

이번엔 Context 의 actions 에 넣어준 함수를 호출하는 컴포넌트 만들기.
components 디렉터리에 SelectColors.js 파일 생성. 먼저 UI부터.

15.4 Consumer 대신 Hook 또는 static contextType 사용하기.

15.4.1 useContext Hook 사용하기

리액트에 내장된 hooks 중에서 useContext 라는 hook 사용하면,
함수 컴포넌트에서 Context 아주 편히 사용할수 있다.

children 에 함수를 전달하는 Render Props 패턴이 불편하다면,
useContext Hook 사용하여 훨씬 편하게 Context 값 조회가능.

Hook 은 함수 컴포넌트 에서만 사용 가능.
클래스형 컴포넌트 에서는 Hook 사용 안됨.

15.4.2 static contextType 사용하기.

클래스형, 건너뜀.

15.5 정리 

기존에는 컴포넌트 간 상태를 교류할때 무조건 부모 -> 자식 흐름으로 
props 통해 전달했지만, 이제는 Context API 통해 더욱 쉽게 상태 교류.

컴포넌트 구조가 꽤 간단하고 다루는 상태의 종류가 그다지 많지 않다면,
굳이 Context 사용할 필요 없다. 
하지만 전역적으로 여기저기서 사용되는 상태가 있고 컴포넌트 개수가 많다면,
Context API 사용을 권장.

다음 장에서는 리덕스 라는 상태 관리 라이브러리 배워보자.
이 라이브러리 는 Context API 기반으로 만듬. 전역 상태 관리에 도움.
Context API 가 개선되기 전엔 주로 리덕스를 사용했음.
단순한 전역 상태 관리라면 Context API로 리덕스를 대체할 수도 있다.

하지만 리덕스는 더욱 향상된 성능과 미들웨어 기능, 강력한 개발자 도구,
코드의 높은 유지 보수성을 제공하기 때문에 모든 상황에는 대체 하지못한다.

16장 리덕스 라이브러리 이해하기.

16.1 개념 미리 정리하기

리덕스는 가장 많이 사용하는 리액트 상태관리 라이브러리.
리덕스를 사용하면 컴포넌트의 상태 업데이트 관련 로직을 다른 파일로 분리시켜
더욱 효율적으로 관리.
또한, 컴포넌트끼리 똑같은 상태를 공유 해야할때도 여러 컴포넌트 거치지 않고
손쉽게 상태 값을 전달하거나 업데이트.

리덕스 라이브러리는 전역 상태를 관리할 때 굉장히 효과적.
물론 리덕스를 사용하는것이 유일한 해결책은 X
Context API 를 통해서도 똑같은 작업 할수있다.
16.3 릴리즈 전에는 주로 리덕스를 사용.

단순히 전역 상태관리만 한다면 Context API 사용만으로도 충분.
하지만 리덕스 사용하면 상태를 더욱 체계적으로 관리할 수 있기 때문에
프로젝트의 규모가 클 경우엔 리덕스를 사용하는 편이 좋다.
코드의 유지 보수성도 높여주고 작업 효율도 극대화 해주기 때문.

추가로 아주 편리한 개발자 도구도 지원하며, 미들웨어라는 기능을 제공하여
비동기 작업을 훨씬 효율적으로 관리.

실습 진행 순서
-1) 핵심 키워드 알아보기
-2) Parcel 로 프로젝트 구성하기
-3) 토글 스위치와 카운터 구현하기.

16.1 개념 미리 정리하기

앞으로 리덕스 사용하면서 접하게 될 키워드의 개념을 간략히 알아보자.
도중에 잘 이해되지 않는 내용은 나중에 직접 사용해 본 다음 여기로 돌아오자.

16.1.1 액션


상태에 어떠한 변화가 필요하면 '액션' 이 발생함.
이는 하나의 객체로 표현됨.
{
	type: 'TOGGLE_VALUE'
}

액션 객체는 type 필드를 반드시 가지고 있어야 한다.
이 값을 액션의 이름이라고 생각하면됨.
그리고 그외의 값들은 나중에 상태 업데이트를 할 때 참고할 값이며,
작성자 마음대로 넣을수 있다.

16.1.2 액션 생성 함수

액션 생성함수 ( action creator ) 는 액션 객체를 만들어 주는 함수.

어떤 변화를 일으켜야 할 때마다 액션 객체를 만들어야 하는데
매번 액션 객체를 직접 작성하기 번거로울수 있고, 만드는 과정에서
실수로 정보를 놓칠수도 있다.

이런 일을 방지하기위해 이를 함수로 만들어 관리.

16.1.3 리듀서

리듀서(reducer) 는 변화를 일으키는 함수.
액션을 만들어서 발생시키면 리듀서가 현재 상태와 전달받은 액션 객체를
파라미터로 받아옵니다.
그리고 두 값을 참고하여 새로운 상태 만들어서 반환.

( 현재상태, 액션객체 )

16.1.4 스토어

프로젝트에 리덕스 적용하기 위해 스토어(store) 를 만든다.
한개의 프로젝트는 단하나의 스토어만 가질수 있다.
스토어 안에는 현재 애플리케이션 상태와 리듀서가 들어가 있으며,
그외에도 몇가지 주용한 내장함수 지님.

16.1.5 디스패치

디스패치(dispatch) 는 스토어의 내장 함수중 하나.
디스패치는 '액션을 발생시키는 것' 이라고 이해하면 된다.

이 함수는 dispatch(action) 과 같은 형태로
액션 객체를 파라미터로 넣어서 호출.
이 함수가 호출되면 스토어는 리듀서 함수를 실행 시켜서 새로운 상태를 만들어줌.

16.1.6 구독
구독(subscribe) 도 스토어의 내장 함수중 하나.
subscribe 함수 안에 리스너 함수를 파라미터로 넣어서 호출 해주면,
이 리스너 함수가 액션이 디스패치 되어 상태가 업데이트 될 때마다 호출.

16.2 리액트 없이 쓰는 리덕스

리덕스는 리액트에 종속되는 라이브러리가 아님.
리액트에서 사용하려고 만들어 졌지만, 실제로 다른 UI 라이브러리 /
프레임워크 와 함께 사용할 수도 있다.
(예: angular-redux, ember redux, Vue 에서도 사용가능하지만
Vue는 리덕스와 유사한 vuex 를 주로 사용. )

리덕스는 바닐라 JS 와 함께 사용할 수도 있다.
바닐라 JS는 라이브러리 나 프레임워크 없이 사용하는 순수 JS 자체.

이번에는 바닐라 JS 환경에서 리덕스를 사용해 리덕스의 핵심 기능과
작동원리를 이해해 보자.

16.2.1 Parcel 로 프로젝트 만들기

프로젝트를 구성하기위해 Parcel 이라는 도구 사용.
이 도구 사용하면 아주 쉽고 빠르게 웹 애플리케이션 프로젝트 구성가능.

parcel-bundler 설치.

16.2.3 DOM 레퍼런스 만들기

이번 프로젝트 에서는 UI 관리할때 별도의 라이브러리 사용하지 않기 때문에
DOM 을 직접 수정해 줘야 한다. 
다음과 같이 JS 파일 상단에 수정할 DOM 노드를 가리키는 값 미리선언.

16.2.4 액션 타입과 액션 생성함수 정의

프로젝트 상태에 변화 일으키는것을 액션 이라고함.
먼저 액션에 이름을 정의. 액션 이름은 문자열 형태로,
주로 대문자로 작성하며 액션 이름은 고유해야 한다.
이름이 중복되면 의도하지 않은 결과 나올수 있음.

그 다음엔 이 액션이름 사용하여 액션 객체 만드는 액션생성함수 작성.
액션 객체는 type 값을 반드시 가지고, 추후 상태를 업데이트할때
참고하고 싶은 값은 마음대로 넣어라.

16.2.5 초깃값 설정.

이 프로젝트에서 사용할 초깃값 정의.
초깃값 형태는 자유. 숫자, 문자, 객체 등등

16.2.6 리듀서 함수 정의

리듀서는 변화를 일으키는 함수입니다.
함수의 파라미터로는 state 와 action 값을 받아옴.

16.2.7 스토어 만들기

스토어를 만들땐 createStore 함수 사용.
이 함수를 사용하려면 코드 상단에 import 구문을 넣어 리덕스에서
해당 함수를 불러와야 하고, 함수의 파라미터에는 리듀서 함수를 넣어야한다.

16.2.8 render 함수 만들기

render 라는 함수를 작성해 보자.
이 함수는 상태가 업데이트 될 때마다 호출되며,
리액트의 render 함수와는 다르게 이미 html 을 사용하여 만들어진 UI의
속성을 상태에 따라 변경해줌.

16.2.9 구독하기

subscribe 는 스토어의 상태가 바뀔 때 마다 render 함수가 호출되도록
해준다.

subscribe 함수의 파라미터로는 함수 형태의 값을 전달
이렇게 전달된 함수는 추후 액션이 발생해 상태가 업데이트 될때마다 호출.

16장의 프로젝트에서는 subscribe 함수를 직접 사용하지만,
추후 리액트 에서는 리덕스 사용시 이함수를 직접 사용하지 않는다.
왜냐하면, 컴포넌트에서 리덕스 상태 조회하는 과정에서 react-redux 라이브러리가
이 작업을 대신해줌.

상태가 업데이트 될때마다 render 함수 호출하도록 코드 작성.

16.2.10 액션 발생시키기.

디스패치 : 액션을 발생시키는 것.
디스패치 를 할 때는 스토어의 내장 함수 dispatch 사용.
파라미터는 액션 객체 넣어주면 됨.

다음과 같이 각 DOM 요소에 클릭이벤트 설정.
이벤트 함수 내부에서는 dispatch 함수를 사용해 액션을 스토어에게 전달.

16.3 리덕스의 세가지 규칙.

16.3.1 단일스토어 
하나의 애플리케이션 안에는 하나의 스토어가 들어있음.
사실 여러개의 스토어를 사용하는것이 완전히 불가능 하지는 않다.
특정 업데이트가 너무 빈번히 일어나거나 애플리케이션 의 특정 부분을
완전히 분리 시켜야할때 여러개의 스토어를 만들수도 있지만,
상태 관리가 복잡해지므로 권장하지 않는다.

16.3.2 읽기 전용 상태.
리덕스 상태는 읽기 전용이다. 기존에 리액트에서 setState 를 사용하여
state 업데이트 할때도 객체나 배열을 업데이트 하는 과정에서
불변성을 지켜주기 위해 spread 연산자를 사용하거나 immer 같은
불변성 관리 라이브러리를 사용했었다.
리덕스도 마찬가지로 상태 업데이트 할때 기존의 객체는 건드리지 않고
새로운 객체 생성 해주어야함.

리덕스 에서 불변성 유지하는 이유는 내부적으로 데이터가 변경되는 것을
감지하기 위해 얕은 비교 ( shallow equality ) 검사를 하기 때문.
객체의 변화를 감지할 때 객체의 깊숙한 안쪽까지 비교하는것이 아닌,
겉핥기 식으로 비교하여 좋은 성능을 유지할수 있다.

16.3.3 리듀서는 순수한 함수.
변화를 일으키는 리듀서 함수는 순수한 함수여야함.
순수한 함수가 만족하는 조건?

- 리듀서 함수는 이전 상태와 액션 객체를 파라미터로 받는다.
- 파라미터 외의 값에는 의존 하면 안됨.
- 이전 상태는 절대 건들지 않고, 변화를 준 새로운 상태 객체를 만들어 반환.
- 똑같은 파라미터로 호출된 리듀서 함수는 언제나 똑같은 결과값을 반환해야함.

리듀서를 작성할땐 위 네가지 사항 주의.
예를 들어 리듀서 함수 내부에서 랜덤 값 만들거나,
Date 함수 사용하여 현재시간 가져오거나,
네트워크 요청을 한다면 파라미터가 같아도 다른 결과가 나오기 때문에
사용하면 안된다.
이러한 작업은 리듀서 함수 바깥에서 처리.
액션 만드는 과정에서 처리해도 되고,
추후 배울 리덕스 미들웨어에서 처리해도 됨.
주로 네트워크 요청과 같은 비동기 작업은 미들웨어를 통해 관리.

16.4 정리.
지금까지 리덕스 라이브러리 가 어떤 방식으로 작동하는지 알아 보았다.
다음장 에서는 리액트 프로젝트에서 리덕스 사용하는 방법 알아보자.
리덕스 코드를 작성하는 흐름은 이번 장과 매우 유사하다.
먼저 액션 타입과 액션 생성 함수를 작성하고, 이어서 리듀서 작성하고,
스토어를 만든다.
이번 프로젝트에서는 함수에서 스토어 구독 작업을 직접 했지만,
다음장에선 react-redux 라는 라이브러리를 사용하여 스토어의 상태가 
업데이트 될 때마다 컴포넌트 리렌더링 시켜줌.

