17장 리덕스를 사용하여 리액트 애플리케이션 상태 관리하기.

이번 장에서는 리덕스를 사용해 리액트 애플리케이션 상태를 관리하는 방법을
알아본다. 소규모 프로젝트 에서는 컴포넌트 가 가진 state 를
사용하는 것만으로도 충분하지만, 프로젝트 규모가 커짐에 따라 상태관리가
번거로워 질 수 있다.

리액트 애플리케이션 에서 리덕스를 사용하면, 상태 업데이트 에 관한
로직을 모듈로 따로 분리하여 컴포넌트 파일과 별개로 관리 할수 있으므로
코드를 유지 보수하는데 도움이 된다.
또한, 여러 컴포넌트 에서 동일한 상태를 공유해야 할때 매우 유용하며,
실제 업데이트가 필요한 컴포넌트만 리렌더링 되도록 쉽게 최적화 해줄 수
있다.

앞에서 바닐라 자바스크립트 환경에서 리덕스를 사용할 때 스토어의 내장 함수인
store.dispatch 와 store.subscribe 함수 사용.
리액트 애플리케이션 에서 리덕스를 사용할땐 store 인스턴스를
직접 사용하기 보다는 주로 react-redux 라는 라이브러리 에서 제공하는
유틸 함수 (connect) 와 컴포넌트(Provider) 를 사용하여
리덕스 관련 작업 처리.

실습 진행 순서
-1) 프로젝트 준비
-2) 프레젠테이셔널 컴포넌트 작성
-3) 리덕스 관련 코드 작성
-4) 컨테이너 컴포넌트 작성
-5) 더 편하게 사용하는 방법 알아보기
-6) connect 대신 Hooks 사용하기.

17.1 작업 환경 설정

프로젝트 생성후, yarn add redux react-redux 라이브러리 설치.

17.2 UI 준비하기

리액트 프로젝트 에서 리덕스를 사용할때 가장 많이 사용하는 패턴은
프레젠테이셔널 컴포넌트 와 컨테이너 컴포넌트를 분리하는 것 이다.
프레젠테이셔널 컴포넌트란 주로 상태관리가 이루어지지 않고,
그저 props를 받아와 화면 UI를 보여주기만 하는 컴포넌트 를 말함.
이와 달리 컨테이너 컴포넌트 는 리덕스와 연동되어 있는 컴포넌트 로,
리덕스로 부터 상태를 받아오기도 하고 리덕스 스토어에 액션을 디스패치
하기도 한다.

이런 패턴은 리덕스를 사용하는데 필수사항 은 아니다.
다만 이 패턴을 사용하면 코드의 재사용성도 높아지고, 관심사의 분리가 이루어져
UI를 작성할 때 좀더 집중 할수있다.

이번 프로젝트 에서는 이 패턴을 사용하여 코드 작성.
UI에 관련된 프레젠테이셔널 컴포넌트 는 src/components 경로,
리덕스와 연동된 컨테이너 컴포넌트 src/containers 컴포넌트 에 작성.

17.2.1 카운터 컴포넌트 만들기

숫자 더하고 뺄수있는 카운터 컴포넌트 만들기.

17.2.2 할일 목록 컴포넌트

파일 하나에 두 컴포넌트 선언했다.
취향에 따라 Todos 컴포넌트 와 TodoItem 컴포넌트 파일 두개로 분리해도되고,
위 코드 처럼 파일 하나에 작성할 수도있다.

위 컴포넌트 들이 받아오는 props 는 나중에 사용.

컴포넌트 를 다만들었다면 App 컴포넌트 에서 카운터 아래에 렌더링.
hr 태그를 사용해 사이에 구분선 그리기.

17.3 리덕스 관련 코드 작성하기

이제 프로젝트 에 리덕스 사용해보자.
리덕스 관련 코드를 준비.
리덕스 사용할때는 액션타입, 액션생성함수, 리듀서 코드 작성.
이 코드를 각각 다른 파일에 작성하는 방법도 있고,
기능별로 묶어서 파일 하나에 작성하는 방법도 있다.

actions, constants, reducers 라는 세개의 디렉터리를 만들고,
그안에 기능별로 파일을 하나씩 만드는 방식
코드를 종류에 따라 다른 파일에 작성하여 정리할수 있어 편리하지만,
새로운 액션을 만들때 마다 세 종류의 파일을 모두 수정해야하 기 떄문에
불편하기도 하다.
이 방식은 리덕스 공식문서에서도 사용되므로 가장 기본적이라 할수 있지만,
사람에 따라선 불편할 수도 있는 구조.

Ducks 패턴은 액션 타입, 액션 생성함수, 리듀서 함수를 기능별로
파일 하나에 몰아서 다 작성하는 방식.
앞서 설명한 일반적인 구조로 리덕스를 사용하다가
불편함을 느낀 개발자들이 주로 사용.

리덕스 관련 코드에 대한 디렉터리 구조는 정해진 방법이 없기 때문에
마음대로 작성해도 되지만, 위 두가지 방법이 주로 사용됨.
이책에선 두번쨰로 소개한 방식인 Ducks 패턴을 사용하여 코드작성.

17.3.1 counter 모듈 작성하기.

Ducks 패턴을 사용하여 액션타입, 액션생성함수, 리듀서를 작성한 코드를
'모듈' 이라고함. counter 모듈부터 해보자.

17.3.1.1 액션 타입정의

17.3.1.2 액션 생성 함수 만들기.

주의할점은 앞부분에 export 키워드 들어감.
이렇게 함으로써 추후 이 함수를 다른파일에서 불러올수 있다.

17.3.1.3 초기 상태 및 리듀서 함수 만들기.

이 모듈의 초기상태에는 number 값 설정.
리듀서 함수에는 현재 상태를 참조하여 새로운 객체를 생성해서 반환.
마지막으로 export default 했음

조금전에 만든 액션생성함수 는 export 로 내보내주고, 
이번에 만든 리듀서는 export default 했다.
두 방식의 차이점은 export 는 여러개, export default 는 단한개.

불러오는 방식도 다르다.
{} 로 묶여있음 export , 그냥 불러오면 export default

17.3.2 todos 모듈 만들기.

17.3.2.1 액션타입 정의하기.

17.3.2.2 액션 생성 함수 만들기.

조금 전과 달리 이번에는 액션생성함수 에서 파라미터 가 필요.
전달받은 파라미터 는 액션 객체 안에 추가 필드로 들어간다.

위 액션 생성함수 중에서 insert 함수는 액션 객체를 만들 때
파라미터 외에 사전에 이미 선언된 id 값에도 의존.
insert 는 호출 될때마다 id값에 1씩 더해줌.
이 id 값은 각 todo 객체가 들고 있게될 고유값.

여기서 id값이 3인 이유는 다음절에서 초기상태 작성할때
todo 객체 두개를 사전이 미리 넣어 둘것임.
그래서 새로 추가될 항목 id가 3이기 때문.

17.3.2.3 초기 상태 및 리듀서 함수 만들기.

이제 모듈의 초기 state 와 리듀서 함수 작성.
이번에는 업데이트 방식이 조금 까다로워짐.
객체에 한개 이상의 값이 들어가므로 불변성을 유지 해줘야한다. ( 나머지값 )
spread 연산자를 잘 활용 해라. 배열에 변화 줄때는 배열 내장함수 사용.

17.3.3 루트 리듀서 만들기

이번 프로젝트 에서는 리듀서를 여러개 만들었다.
나중에 createStore 함수를 사용하여 스토어를 만들 땐 리듀서를 하나만 사용.
그렇기 때문에 기존에 만들었던 리듀서를 하나로 합치는 과정 해야함.
이 작업은 리덕스에서 제공하는 combineReducers 라는 유틸함수 사용.

파일 이름을 이렇게 index.js 로 설정해두면 나중에 불러올때
디렉터리 이름까지만 입력하여 불러올수 있다. (디렉터리의 메인 파일이기떄문인듯)
꼭 index로 만들 필요는 없는듯

17.4 리액트 애플리케이션에 리덕스 적용하기

17.4.1 스토어 만들기

스토어를 만들고 리액트 애플리케이션 에 리덕스를 적용하는 작업은
src 디렉터리 의 index.js 에서 이루어진다.

17.4.2 Provider 컴포넌트 사용하여 프로젝트에 리덕스를 적용

리액트 컴포넌트 에서 스토어를 사용할 수 있도록 App 컴포넌트를
react-redux 에서 제공하는 Provider 컴포넌트로 감싸줌.
이 컴포넌트를 사용할 떄는 store 를 props 로 전달.

17.4.3 Redux DevTools 의 설치 및 적용.

Redux DevTools 는 리덕스 개발자 도구이며, 크롬 확장 프로그램으로 
사용.

17.5 컨테이너 컴포넌트 만들기

이제 컴포넌트 에서 리덕스 스토어에 접근하여 원하는 상태 받아오고,
또 액션도 디스패치 해줄 차례. 리덕스 스토어와 연동된 컴포넌트를
컨테이너 컴포넌트 라고 부른다.

17.5.1 CounterContainer 만들기

컨테이너 컴포넌트를 리덕스와 연동 하려면 react-redux 에서 제공하는
connect 함수를 사용.

connect(mapStateToProps, mapDispatchToProps)(연동할 컴포넌트)

mapStateToProps 는 리덕스 스토어 안의 상태를 컴포넌트의 props 로
넘겨주기위해 설정.
mapDispatchToProps 는 액션생성함수 를 컴포넌트의 props 로 
넘겨주기위해 설정.

이렇게 connect 함수를 호출하고 나면 또 다른 함수를 반환.
반환된 함수에 컴포넌트를 파라미터로 넣어주면 리덕스와 연동된 컴포넌트 만들어짐.

const makeContainer = connect(mapStateToProps, mapDispatchToProps)
makeContainer(타겟 컴포넌트)

와 같은 형태다.

mapStateToProps 와 mapDispatchToProps 에서 반환하는 
객체 내부의 값들은 컴포넌트 props 로 전달.
mapStateToProps 는 state 를 파라미터로 받아오며,
이 값은 현재 스토어가 지닌 상태 가리킴.
mapDispatchToProps 의 경우 store 의 내장함수 
dispatch 를 파라미터로 받아옴.
현재 mapDispatchToProps 에서는 진행 절차를 설명하기 위해
임시로 console.log 를 사용.

App 에서 CounterContainer 로 교체해보기.
브라우저 콘솔에서 increase 와 decrease 찍어보기

콘솔로그 대신 액션생성함수 불러와서 액션 객체 만들고 디스패치 해보자.

connect 함수를 사용할 땐 일반적으로 위 코드같이
mapStateToProps 와 mapDispatchToProps 를 미리 선언해놓고 사용.
하지만 connect 함수 내부에 익명 함수 형태로 선언해도 문제 X
어떻게 보면 코드가 더 깔끔해진다.

액션생성함수 를 호출하여 디스패치 하는 코드가 한줄 이기 때문에
불필요한 코드블록 생략. 다음 코드는 작동 방식이 완전히 같다.

increase: () => dispatch(increase()),
increase: () => { return dispatch(increase()) },

컴포넌트 에서 액션을 디스패치 하기위해 각 액션생성함수 함수를 호출하고
dispatch 로 감싸는 작업이 조금 번거로울수 있다.
특히 액션 생성 함수의 개수가 많아진다면 더더욱 그런데,
이와 같은 경우에는 리덕스에서 제공하는 bindActionCreators 유틸함수 사용.

한가지 더 편한방법 있음.
mapDispatchToProps 에 해당하는 파라미터를 함수 형태가 아닌
액션생성함수 로 이루어진 객체 형태로 넣어주는것.

17.5.2 TodosContainer 만들기.

Todos 컴포넌트 를 위한 컨테이너 인 TodosContainer 작성하기.
connect 함수 사용하고, map 어쩌구를 간략화 하는 방법 적용.

todos 모듈에서 작성했던 액션생성함수 와 상태 안에 있던 값을
컴포넌트 의 props 로 전달해 주었다.

다음은 Todos 컴포넌트 에서 받아온 props 사용하도록 구현.

17.6 리덕스 더 편하게 사용하기.

액션생성함수, 리듀서 작성시 redux-actions 라는 라이브러리 와
이전에 배웠던 immer 라이브러리 활용하면 리덕스 훨씬 편히 사용.

17.6.1 redux-actions

redux-actions 사용시 액션생성함수 함수를 더 짧은 코드로 작성 가능.
리듀서 작성시에도 switch/case 문이 아닌 handleActions 함수를 사용하여 
각 액션마다 업데이트 함수를 설정하는 형식으로 작성.

17.6.1.1 counter 모듈에 적용하기.

counter 모듈에 작성된 액션생성함수 를 createAction 이란 함수 사용해서
만들어보기.

createAction 사용시 매번 객체를 직접 만들 필요없이 더욱 간단히
액션생성함수 선언 할수있다.

리듀서 함수도 더 간단하고 가독성 높게 작성하기.
handleActions 함수 사용.

handleActions 함수의 첫 번째 파라미터 에는 각 액션에 대한
업데이트 함수 넣고, 두 번째 파라미터 에는 초기상태 넣어줌.

17.6.1.2 todos 모듈에 적용하기.

todos 모듈에도 똑같이 작업 해보자.
먼저 액션생성함수 교체 할건데, 조금 다른점이 있다.
바로 각 액션생성함수 에서 파라미터 를 필요로 한다.

createAction 으로 액션을 만들면 액션에 필요한 추가 데이터는
payload 라는 이름을 사용한다.

액션생성함수 에서 받아온 파라미터 를 그대로 payload 넣을게 아니라
변형을 하고싶다면, createAction 의 두번째 함수에 payload 를 정의하는
함수를 따로 선언해서 넣어줌.

createAction( type, x => `${ x }!` )

insert 의 경우 todo 객체를 액션객체 안에 넣어줘야 하기 때문에
두번째 파라미터 에 text 를 넣으면 todo 객체가 반환되도록 했다.

나머지 함수에는 파라미터를 그대로 반환하는 함수를 넣었다.
생략해도 똑같이 작동하지만, 이 함수를 넣어 줌으로써 코드를 보았을때
이 액션생성함수 의 파라미터 로 어떤값이 필요한지 쉽게 파악할수 있다.

handleActions 로 리듀서 재작성 해보자.
createAction 으로 만든 액션생성함수 는 파라미터 로 받아온 값을
객체 안에 넣을때 원하는 이름으로 넣는게 아닌
action.id, action.todo 와 같이 action.payload 라는 이름을
공통적으로 넣어준다.
그렇기 때문에, 기존 업데이트 로직에서도 모두 action.payload 값을
조회하여 업데이트 하도록 구현 해야한다.

액션생성함수 는 액션에 필요한 추가 데이터를 모두 payload 라는 이름으로
사용하기 때문에 action.id, 대신 모두 공통적으로 action.payload
값을 조회하도록 리듀서 구현.

const todos = handleActions(
  {
    [CHANGE_INPUT]: (state, action) => ({}),
    [INSERT]: (state, action) => ({}),
    [TOGGLE]: (state, action) => ({}),
    [REMOVE]: (state, action) => ({}),
  },
  initialState,
);

위가 기본형태이다.

모든 추가 데이터 값을 action.payload 로 사용하기 때문에
나중에 리듀서 코드를 다시 볼때 헷갈릴수 있다.
객체 비구조화 할당 문법으로 action 값의 payload 이름을 새로 설정하면
action.payload 가 정확히 어떤 값을 의미하는지 더쉽게 파악 가능.

17.6.2 immer

리듀서에서 상태 업데이트시 불변성 유지 해야하기 때문에 앞에서는
spread 연산자와 배열의 내장함수 활용했다.
그러나 모듈의 상태가 복잡할수록 불변성 유지가 까다로워짐.

따라서 모듈의 상태를 설계 할땐 객체의 깊이가 너무 깊어지지 않도록
주의해아함.

객체의 깊이가 깊지 않을수록 추후 불변성 유지 하며 업데이트 할때 수월.
하지만 상황에 따라 상태 값들을 하나의 객체안에 묶어서 넣는것이
코드의 가독성을 높이는데 유리하며, 나중에 컴포넌트에 리덕스를 연동할때도
더욱 편하다.

객체의 구조가 복잡해지거나 객체로 이루어진 배열을 다룰경우, immer 를
사용하면 훨씬 편리하게 상태관리 할수있다.

yarn add immer

counter 모듈처럼 간단한 리듀서에 immer 를 사용하면 오히려 코드가 길어진다.
todos 에 적용해보자.

immer 를 사용한다 해서 한 컴포넌트 내에 모든 업데이트 함수에
immer 를 적용할 필요는 없다.
예를 들어 위 코드에서 TOGGLE 을 제외한 업데이트 함수들은 immer 를
쓰지않는 코드가 오히려 더 짧기 때문에 이전 형태를 유지하는것도 무방.

17.7 Hooks 를 사용해 컨테이너 컴포넌트 만들기

리덕스 스토어와 연동된 컨테이너 컴포넌트 만들떄 connect 함수 대신
react-redux 에서 제공하는 Hooks 를 사용할수도 있다.

17.7.1 useSelector 로 상태조회

useSelector Hook 을 사용하면 connect 함수를 사용하지 않고도
리덕스의 상태를 조회할수 있다.

사용법 : const 결과 = useSelector(상태 선택 함수);

상태선택함수 는 mapStateToProps 와 형태가 똑같다.
CounterContainer 에서 connect 함수 대신 useSelector 사용해
counter.number 값을 조회 함으로써 Counter 에게 props 전달해보자.

17.7.2 useDispatch 를 사용해 액션 디스패치 하기.

useDispatch 라는 Hook 에 대해 알아보자.
이 Hook은 컴포넌트 내부에서 스토어의 내장함수 dispatch 를 사용하게 해줌.
컨테이너 컴포넌트에서 액션을 디스패치 해야한다면 이 Hook 사용.

사용법 : const dispatch = useDispatch();
dispatch({ type: 'SAMPLE' });

INCREASE 와 DECREASE 액션을 발생 시켜보자.

숫자가 바뀌어 컴포넌트가 리렌더링 될때마다 onIncrease 와
onDecrease 함수가 새롭게 만들어짐.
만약 컴포넌트 성능을 최적화 해야하면, useCallback 으로 액션을
디스패치 하는 함수를 감싸는것이 좋다.

useDispatch 를 사용할땐 useCallback 과 함께 사용하는 습관을
들일것을 권장.

17.7.3 useStore 를 사용하여 리덕스 스토어 사용하기.

useStore Hooks 를 사용하면 컴포넌트 내부에서 리덕스 스토어 객체를
직접 사용할수 있다.
useStore 는 컴포넌트 에서 정말 어쩌다 스토어에 직접 접근할 상황에만
사용해야한다. 이를 사용하는 상황은 흔치 않다.

17.7.4 TodosContainer 를 Hooks 로 전환하기

TodosContainer 를 connect 함수 대신 useSelector 와
useDispatch Hooks 를 사용하는 형태로 전환.

이번엔 useSelector 사용시 비구조화 할당 문법 활용.
또한 useDispatch 사용할때 각 액션을 디스패치 하는 함수 만듬.
액션의 종류가 많은데 어떤 값이 액션생성함수 의 파라미터로 사용되어야 하는지
일일이 명시해 주어야 하므로 조금 번거롭다.

17.7.5 useActions 유틸 Hook 을 만들어 사용하기.

useActions 원래 react-redux 에 내장 되어 릴리즈 될 계획이었지만,
리덕스 개발팀에서 꼭 필요하지 않다고 판단되 제외된 Hook 이다.
그대신 공식 문서에 그대로 복사하여 사용하도록 제공중.

이 Hook 을 사용하면, 여러개의 액션을 사용할 경우 코드를 훨씬 깔끔히 할수있음.
src 디렉터리 에 lib 디렉터리 만들고, 그안에 useActions.js 파일 작성.

useActions Hook 은 액션생성함수 를 액션을 디스패치 하는 함수로
변환해 준다. 액션생성함수 를 사용하여 액션 객체를 만들고,
이를 스토어에 디스패치 하는 작업을 해주는 함수를 자동생성 해줌.

useActions 는 두가지 파라미터 필요.
첫 파라미터 는 액션생성함수 로 이루어진 배열.
둘째 파라미터 는 deps 배열이며, 이 배열 원소가 바뀌면 디스패치 하는
함수를 새로 만들게 됨.

TodosContainer 에서 useActions 를 불러와 사용해보자.

17.7.6 connect 함수와 주요 차이점.

배운것들중 더 편한것을 사용하면 된다.

하지만 Hooks 를 사용하여 컨테이너 컴포넌트 를 만들때 잘 알아둘 차이점은
connect 함수는, 부모 컴포넌트가 리렌더링 될때 해당 컨테이너 컴포넌트의
props 가 바뀌지 않으면 리렌더링 이 자동으로 방지.

useSelector 사용시는 성능 최적화를 위해 React.memo 같은 최적화 작업을
해줘야한다.

지금과 같은 경우엔 TodosContainer 의 App 컴포넌트가 리렌더링 되는일이
없으므로 불필요하긴 하다.

17.8 정리

리액트 프로젝트 에서 리덕스를 사용하면 업데이트 관련 로직을
리액트 컴포넌트에서 완벽히 분리가 되므로 유지 보수성이 높은 코드를
작성해 낼수 있다.
사실 이번에 만든 프로젝트 처럼 작은 프로젝트에 리덕스를 적용하면
오히려 프로젝트 복잡도가 높아질 수 있다.
하지만 규모가 큰 프로젝트에 리덕스 적용시 상태를 더 체계적으로 관리할수 있고,
개발자 경험도 향상시켜 준다.
