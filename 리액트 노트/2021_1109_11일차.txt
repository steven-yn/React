19장 코드 스플리팅

리액트 프로젝트를 완성해 사용자에게 제공할땐 빌드 작업을 거쳐서 배포해야함.
빌드 작업을 통해 프로젝트에서 사용되는 자바스크립트 파일 안에서
불필요한 주석, 경고 메세지, 공백등을 제거하여 파일 크기를 최소화하기도 하고,
브라우저에서 JSX 문법이나 다른 최신 JS 문법이 원활히 실행되도록
코드의 트랜스파일 작업도 할수 있다.
만약 프로젝트 내에 이미지 같은 정적 파일이 있다면 해당 파일을 위한 경로도 설정.

이 작업은 웹팩 (webpack) 이라는 도구가 담당.
웹팩에서 별도의 설정을 하지 않으면 프로젝트 에서 사용중인 모든 JS 파일이 
하나의 파일로 합쳐지고, 모든 CSS 파일도 하나의 파일로 합쳐진다.

CRA 로 프로젝트 빌드시 최소 두개 이상의 JS 파일이 생성된다.
CRA 의 기본 웹팩 설정에는 SplitChunks 라는 기능이 적용되어
node_modules 에서 불러온 파일, 일정 크기 이상의 파일, 여러 파일간에
공유된 파일을 자동으로 따로 분리시켜 캐싱의 효과를 제대로 누릴수 있게 해줌.

리액트 프로젝트를 빌드 해보자.

yarn build 

생성된 build 디렉터리를 확인해보면 '7b7f7f25' 같은 해시 값이 포함됨.
이 값은 빌드하는 과정에서 해당 파일의 내용에 따라 생성되며,
이를 통해 브라우저가 새로 파일을 받아야 할지 말지를 알수 있다.

2로 시작하는 파일에는 React, ReactDOM 등 node_modules 에서
불러온 라이브러리 관련 코드가 들어있고, main 으로 시작하는 파일에는
직접 프로젝트에 작성하는 App 같은 컴포넌트 에 대한 코드가 들어있다.
2로 시작하는 파일은 코드가 엄청 긴 반면, main 으로 시작하는 파일은
코드가 매우 짧을 것이다.

조금전 언급한 SplitChunks 라는 웹팩 기능을 통해 자주 바뀌지 않는 코드들이
2로 시작하는 파일에 들어있기 때문에 캐싱의 이점을 더 오래 누릴수 있다.

2로 시작하는 파일 이름을 확인해주고, App.js 코드를 변경.

재빌드 후 build/static 디렉터리를 다시 열어보면,
기존에 node_modules 에서 불러온 라이브러리가 들어있던
2로 시작하는 파일은 바뀌지 않았고, main 으로 시작하는 파일 이름만 바뀜.
작성하는 컴포넌트에 관련된 파일이기 때문.

이렇게 파일을 분리하는 작업을 코드 스플리팅 이라고한다.
프로젝트 에 기본 탑재된 SplitChunks 기능을 통한 코드 스플리팅은
단순히 효율적인 캐싱 효과만 있을 뿐이다.

예를 들어 a,b,c 로 구성된 SPA 를 개발한다고 가정해 보자.
사용자가 A 페이지에 방문했다면 B 페이지와 C 페이지에서 사용하는 컴포넌트
정보는 필요하지 않다.
사용자가 실제로 B 혹은 C 페이지로 이동하려고 할때만 필요하다.

하지만 프로젝트에 별도로 설정하지 않으면 a,b,c 컴포넌트에 대한 코드가
모두 한 파일 main 에 저장되버린다.
만약 애플리케이션의 규모가 커지면 지금 당장 필요하지 않은 컴포넌트 정보도
모두 불러오면서 파일 크기가 매우 커진다.
그러면 로딩이 오래 걸리기 때문에 사용자 경험도 안좋아지고 트래픽도 많이 나온다.

이러한 문제점을 해결해 줄수 있는 방법이 바로 코드 비동기 로딩.
이 또한 코드 스플리팅 방법중 하나.
코드 비동기 로딩을 통해 JS 함수, 객체, 혹은 컴포넌트를 처음에는 불러오지 않고
필요한 시점에 불러와서 사용.

실습 진행 순서
-1) 자바스크립트 함수 비동기 로딩.
-2) React.lazy 와 Suspense 를 통한 컴포넌트 비동기 렌더링.
-3) Loadable Components 를 통한 컴포넌트 비동기 렌더링.

19.1 자바스크립트 함수 비동기 로딩.

컴포넌트 코드를 스플리팅 하기에 앞서 일반 자바스크립트 함수를 스플리팅 해보자.
src 디렉터리에 notify.js 생성.

앱 컴포넌트 안에 import 해서 작성하고 빌드하면 notify 코드가
main 파일안에 들어가게 된다.
하지만 다음과 같이 import 를 상단에서 하지 않고
import() 함수 형태로 메서드 안에서 사용하면, 파일을 따로 분리시켜 저장.
그리고 실제 함수가 필요할때만 notify 가 포함된 파일을 불러와서
함수를 사용할수 있다.

import 를 함수로 사용하면 Promise 를 반환.
이렇게 import 를 함수로 사용하는 문법은 아직 표준 JS가 아니지만,
stage-3 단계에 있는 dynamic import 라는 문법.
현재는 웹팩에서 지원하므로 별도의 설정없이 프로젝트에 바로 사용할수 있다.
이 함수를 통해 모듈을 불러올때 모듈에서 default 로 내보낸것은
result.default 를 참조해야 사용할수 있다.

실행시켜보면, Hello React! 를 클릭하는 시점이 되야 파일을 불러온다.
불러온 파일 내용을 확인해 보면, notify 에 관련된 코드만 있다.

이제 yarn build 해보자.

해보면 3으로 시작하는 파일안에 notify 관련 코드가 들어간다.

19.2 React.lazy 와 Suspense 를 통한 컴포넌트 코드 스플리팅

코드 스플리팅 을 위해 리액트에 내장된 기능으로
유틸 함수인 React.lazy 와 컴포넌트인 Suspense 가 있다.
이 기능은 리액트 16.6 버전부터 도입.
이전 버전에서는 import 함수를 통해 불러온 다음,
컴포넌트 자체를 state 에 넣는 방식으로 구현.

19.2.1 state 를 사용한 코드 스플리팅

React.lazy 를 사용하기에 앞서, React.lazy 없이 코드를 스플리팅 하면
어떻게 해야하는 지 알아보자.

그만 알아보자 (클래스형)

19.2.2 React.lazy 와 Suspense 사용하기.

React.lazy 와 Suspense 를 사용하면 코드 스플리팅을 하기위해
state를 따로 선언하지 않고도 정말 간편하게 컴포넌트 코드 스플리팅을
할수 있다.

React.lazy 는 컴포넌트 렌더링 하는 시점에서 비동기 로딩을 할수있게
해주는 유틸함수다.

const SplitME = React.lazy(() => import('./SplitME'));

Suspense 는 리액트 내장 컴포넌트로 코드 스플리팅 된 컴포넌트 를
로딩하도록 발동 시킬수 있고, 로딩이 끝나지 않았을때 보여줄 UI 설정.

import { Suspense } from 'react';

<Suspense fallback={<div>loading...<div>}>
	<SplitME />
</Suspense>

Suspense 에서 fallback props 를 통해 로딩중 보여줄 JSX를
지정할수 있다.

단순히 SplitME 컴포넌트 의 가시성을 의미하는 visible 이란 state 만
업데이트 하여 코드 스플리팅 컴포넌트를 보여줬다.
Network 탭에서 online 클릭하여 속도 느리게 설정해보자.

loading 문구가 뜨는것을 확인.

19.2.3 Loadable Components 를 통한 코드 스플리팅

Loadable Components 는 코드 스플리팅 을 편하게 하도록 도와주는
서드파티 라이브러리다. 이 라이브러리 의 이점은 서버 사이드 렌더링을
지원한다는것.
( React.lazy 와 Suspense 는 아직 서버 사이드 렌더링을 지원안함. )
또한 렌더링 전에 필요할때 스플리팅 된 파일을 미리 불러올수도 있다.

서버 사이드 렌더링 이란 웹 서비스의 초기 로딩속도 개선,
캐싱 및 검색엔진 최적화를 가능하게 해주는 기술.
서버 사이드 렌더링을 사용하면 웹 서비스의 초기 렌더링을 사용자가 아닌
서버쪽 에서 처리함.
사용자는 서버에서 렌더링한 html 결과물을 받아와서 그대로 사용하기 때문에
초기 로딩속도도 개선되고, 검색엔진에서 크롤링할 문제도 없다.
이에 대한 자세한 내용은 다음장에서 알아보자.

라이브러리 설치.
yarn add @loadable/component 

사용법은 React.lazy 와 비슷하지만, Suspense 를 사용할 필요가 없다.

로딩중 다른 UI 를 보여주고 싶다면

const SplitMe = loadable(() => import("./SplitMe"), {
	fallback: <div> loading... </div>
});

다음은 컴포넌트 미리 불러오기.
이렇게 수정시 마우스 커서를 Hello React! 위에 올리기만 해도 로딩시작.
그리고 클릭했을때 렌더링.
브라우저에서 개발자 도구를 열고, 커서를 올리는 시점에 파일이 불러와지는지
확인해보자.
이런 기능 구현하면 나중에 사용자에게 더 좋은 경험을 제공.

Loadable Components 는 미리 불러오는 기능 외에도 타임아웃,
로딩 UI 딜레이, 서버 사이드 렌더링 호환등 다양한 기능 제공.
자세한 내용은 공식문서 확인.
(https://loadable-components.com/docs/delay/)

19.3 정리

이 장에서는 코드 스플리팅이 무엇인지, 컴포넌트 를 어떻게 분리된 파일로 저장하고
또 비동기적으로 불러와서 사용하는지 알아보았다.

서버 사이드 렌더링 할 계획이 없다면 ? React.lazy 와 Suspense
있다면? Loadable Components 라이브러리 사용하도록 권장.

React.lazy 와 Suspense 의 경우 지금 당장은 서버 사이드 렌더링을
지원하지 않지만 추후에는 지원될수도 있으니,
이 기능을 배우고 사용하는 시점에 공식문서를 한번더 확인하길 권장.
https://reactjs.org/docs/code-splitting.html#reactlazy

20장 서버사이드 렌더링. --> 잠시 건너뜀.

21장 백엔드 프로그래밍 : Node.js 의 Koa 프레임 워크

지금까지 리액트의 기본개념 대부분 다뤘다.
웹 애플리케이션 을 만들땐 리액트 같은 프런트엔드 기술만으로 필요한 기능을
구현할수 없는 경우가 흔하다. 데이터를 여러사람과 공유하려면 저장할 공간이
필요하기 때문.

21.1 소개하기

21.1.1 백엔드

우리는 서버를 만들어 데이터를 여러 사람과 공유함.
그런데 서버에 데이터를 무작정 담지는 않는다.
데이터를 담을땐 여러가지 규칙이 필요.

예를 들어 특정 데이터 등록시 사용자 인증정보가 필요할수 있고,
등록할 데이터를 어떻게 검증할지, 데이터가 다양하다면 어떻게 구분할지 고려.
데이터를 조회 할때도 마찬가지. 어떤 종류의 데이터를 몇개씩 보여줄지,
그리고 또 어떻게 보여줄지 등에 관한 로직을 만드는 것을
서버 프로그래밍 또는 백엔드 프로그래밍 이라고 함.

백엔드 프로그래밍 은 여러가지 환경으로 진행할 수 있다.
즉, 언어에 구애받지 않기 때문에 PHP, 파이썬, Golang 등
다양한 언어로 구현할수 있다.
이책에서는 그중 JS로 서버를 구현하는 Node.js 사용해보자.

21.1.2 Node.js

처음에는 JS 를 웹 브라우저만 사용했다.
속도가 그렇게 빠르지도 않았다. 시간이 지나면서 JS는 계속 발전해왔고,
구글이 크롬 웹 브라우저를 소개하면서 V8 이라는 JS 엔진도 공개.
이 JS 엔진을 기반으로 웹 브라우저 뿐만 아니라 서버에서도 JS 를
사용할수 있는 런타임을 개발했는데, 이것이 node.js

21.1.3 Koa
Node.js 환경에서 웹 서버 구축시 보통 Express, Hapi, Koa 등 
웹 프레임워크를 사용.
20장에서 서버 사이드 렌더링 서버를 사용시 Express 사용.
21장 백엔드 개발은 Koa 라는 웹 프레임워크 사용.

Koa 는 Express 의 기존 개발팀이 개발한 프레임워크 다.
기존 Express 에서 고칠점을 개선하면 내부 설계가 완전히 바뀌기 때문에
개발팀이 아예 새로운 프레임워크를 개발.

Express 는 미들웨어, 라우팅, 템플릿, 파일 호스팅과 같은 다양한 기능이
자체적으로 내장된 반면, Koa는 미들웨어 기능만 갖추고 있으며
나머지는 다른 라이브러리를 적용하여 사용.
즉, Koa는 우리가 필요한 기능들만 붙여서 서버를 만들수 있기 때문에
Express 보다 훨씬 가볍다.

추가로 Koa는 async / await 문법을 정식으로 지원하기 때문에
비동기 작업 더 편하게 관리할수 있다.

Node.js 로 서버를 개발할때 어떤 프레임워크를 사용할진 사실 개인적인 취향에
따라서 달라진다.

실습진행순서
-1) 작업 환경 준비
-2) Koa 서버 띄우기
-3) 미들웨어 알아보기.
-4) Koa-router 를 통한 백엔드 라우팅.
-5) 라우트 모듈화하기

21.2 작업 환경 준비

21.2.1 Node 설치 확인

node --version

21.2.2 프로젝트 생성

이번에 만들 백엔드 프로젝트는 이책에서 다루는 마지막 프로젝트인 블로그서비스와
연동할 서버. blog 디렉터리를 만들고, 그내부에 blog-backend 디렉터리 만들기.
해당 디렉터리에서 yarn init -y 명령어 실행하여 패키지 정보 생성.

이 작업 하고나면 디렉터리에 package.json 생성.
다음 명령어 실행하여 해당 파일이 잘 만들어졌는지 확인.
( 혹은 에디터로 직접 열어봐도 된다. )
cat package.json

이제 우리에게 필요한 Koa 웹 프레임워크 설치.
다시 package 열어보면 koa가 dependencies 에 추가.

21.2.3 ESLint 와 Prettier 설정.

서버 파일을 작성하기전 ESLint 와 Prettier 프로젝트에 적용.
두 기능을 VSCode 에서 사용하려면 ESLint 설치.

yarn add --dev eslint
yarn run eslint --init

설정과 설치를 마치고 나면 .eslintrc.json 생성.
prettier 설정.

설정후 Prettier 에서 관리하는 코드 스타일은 ESLint 에서 관리하지 않도록
eslint-config-prettier 설치 및 적용.

yarn add eslint-config-prettier

설치한후 .eslintrc.json 설정 파일 만들면됨.
두 도구가 제대로 작동하는지 확인.
src 디렉터리 생성후 그안에 index.js 파일 생성.

const hello = "hello"; 하면 오류가뜸.
const로 값을 선언하고 사용하지 않으면, ESLint 기본설정은 이를
에러로 간주.
hello' is assigned a value but never used.eslintno-unused-vars

사용되지 않는 const 값은 문법적으로 문제없지만,
더 나은 코드를 작성하도록 장려하기 위해 ESLint 는 이를 오류로 취급.

이러한 규칙을 끌수도 있다. 오류이름을 알아두면 .eslintrc.json 에서 
오류를 경고로 바꾸거나 비활성화 할 수 있다.

수정한뒤 저장하고, 에디터에서 파일 닫고 다시 열어주면 반영됨.
no-console 값에 'off' 는 ESLint 기본설정에선 console.log 사용을 
지양하고 있다. 그래서 이 규칙을 비활성화.
또한, Prettier 를 통해 따옴표 변환 확인. 저장시 자동으로 코드 정리하는
설정을 활성화 하지 않았다면 F1 누른후 format 이라고 입력.
