
21.3 Koa 기본 사용법 

21.3.1 서버 띄우기

서버 여는 방법부터 알아보자.
코드 작성후 서버 포트를 4000번으로 열고, 서버에 접속시 'hello world'
텍스트가 반환되도록 설정.

원래 node 를 통해 JS 파일 실행시 node src/index.js 와 같이
전체 경로를 입력하는 것이 맞지만, index.js 파일은 예외로 디렉터리까지만
입력해도 실행할 수 있다.
index.js 는 해당 디렉터리를 대표하는 파일이다.

localhost:4000 으로 접속.

21.3.2 미들웨어 

Koa 애플리케이션은 미들웨어의 배열로 구성. 
조금전 코드에서 app.use 함수를 사용했는데, 이 함수는 미들웨어 함수를
애플리케이션 에 등록함.

미들웨어 함수는 다음같은 구조.
(ctx, next) => {}

Koa 의 미들웨어 함수는 두개의 파라미터 받는다.
첫째 파라미터 는 조금 전에도 사용한 ctx 라는 값이고,
둘째 파라미터 는 next 다.

ctx 는 Context 의 줄임말 로 웹 요청과 응답에 관한 정보 지님.
next 는 현재 처리중인 미들웨어의 다음 미들웨어를 호출하는 함수.
미들웨어를 등록하고 next 함수를 호출하지 않으면, 그다음 미들웨어 처리안함.

만약 미들웨어에서 next 를 사용하지 않으면, ctx => {} 같은 형태로
파라미터 에 next 를 넣지 않아도 된다.
주로 다음 미들웨어 를 처리할 필요가 없는 라우트 미들웨어 를 설정할때
이러한 구조가 됨.

미들웨어는 app.use 를 사용해 등록되는 순서대로 처리됨.
다음과 같이 현재 요청을 받은 주소와 우리가 정해준 숫자를 기록하는
두개의 미들웨어 작성.

실행중인 서버 종료 후, 다시 node src 명령어 입력.
그리고 localhost:4000 을 연후 터미널을 확인하면 
Listening to port 4000
/
1
2
/favicon.ico
1
2

과 같은 결과가 나온다.

크롬 브라우저는 사용자가 웹 페이지에 들어가면 해당 사이트의 아이콘 파일인
/favicon.ico 파일을 서버에 요청하기 때문에 결과에 / 경로도 나타나고
/favicon.ico 경로도 나타난다.

이번에는 첫번째 미들웨어에서 호출하던 next 함수를 주석으로 처리.

next 미호출시 첫번째 미들웨어 까지만 실행하고, 그아래 미들웨어 모두 무시.
이런 속성을 사용해 조건부로 다음 미들웨어 처리를 무시하게 만들수 있다.
다음 코드에서는 요청 경로에 authorized=1 이라는 쿼리 파라미터가 포함되면
이후 미들웨어를 처리해주고, 그렇지 않으면 이후 미들웨어를 처리하지 않음.

쿼리 파라미터는 문자열 이기 때문에 비교할땐 꼭 문자열 형태로 비교.

서버 재시작후 경로에 ?authorized=1 을 입력하고 결과확인.

지금은 단순히 주소의 쿼리 파라미터를 사용해 조건부 처리했지만, 나중에는
웹 요청의 쿠키 혹은 헤더를 통해 처리할수도 있다.

21.3.2.1 next 함수는 Promise 를 반환

이는 Koa 가 Express 와 차별화 되는 부분.
next 함수가 반환하는 Promise 는 다음에 처리할 미들웨어가 끝나야 완료.
다음과 같이 next 함수 호출 이후에 then 을 사용해 Promise가 끝난다음
콘솔에 END 를 기록하도록 수정.

END 가 나타나는것을 확인. ( 브라우저 버전에 따라 /favicon.ico 를
요청하지 않을수도 있다. )

21.3.2.2 async / await 사용하기

Koa 는 async/await 을 정식으로 지원하기 때문에 해당 문법을
아주 편하게 사용할수 있음.

서버 사이드 렌더링시 사용한 Express 도 async/await 문법을 사용할수
있지만, 오류를 처리하는 부분이 제대로 작동하지 않을 수 있다.
백엔드 개발을 하면서 예상치 못한 에러를 제대로 잡으려면 express-async-
errors 라는 라이브러리 따로 사용.

기존 코드를 async/await 사용하는 형태로 수정하기.
서버를 재시작 했을때 END 출력.

21.4 nodemon 사용하기.

서버 코드 변경할떄마다 서버를 재시작 하는것은 꽤 번거롭다.
nodemon 이라는 도구를 사용하면 코드를 변경할떄마다 서버를 자동으로 재시작.

개발용 의존 모듈로 설치.

yarn add -dev nodemon

그 다음 package.json 에 scripts 에 추가하기.

start 스크립트에 서버를 시작하는 명령어를 넣고,
start:dev 스크립트에 nodemon 을 통해 서버 실행하는 명령어 넣어줌.
여기서 nodemon 은 src 디렉터리를 주시하고 있다가 해당 디렉터리 내부의
어떤 파일이 변경되면, 이를 감지하여 src/index.js 파일을 재시작 해줌.

이제는 다음 명령어 사용해서 서버 시작.

yarn start	# 재시작이 필요없을때
yarn start:dev # 재시작이 필요할때 

기존에 실행중이던 서버를 종료하고 yarn start:dev 명령어를 실행.
그다음 index.js 에서 기존 미들웨어 모두제거하고 저장해보기.

매번 서버 수동으로 재시작하는 번거로움이 사라진다.

21.5 Koa-router 사용하기.

앞에서 리액트 배울때 웹 브라우저의 라우팅을 돕는 리액트 라우터 라이브러리
사용해 보았다. Koa 를 사용할때도 다른 주소로 요청이 들어올 경우
다른 작업을 처리할수 있도록 라우터를 사용해야한다.
Koa 자체에 이 기능이 내장되어 있지는 않으므로, Koa-router 모듈 설치.

yarn add koa-router

21.5.1 기본 사용법

index.js 에서 라우터를 불러와 적용해보기.

koa-router 를 불러온뒤 이를 사용해 Router 인스턴스 만들었다.
그리고 / 경로로 들어오면 '홈' 을 띄우고, /about 경로로 들어오면
'소개' 텍스트가 나타나도록 설정.

이처럼 라우트를 설정할때, router.get 의 첫번째 파라미터 에는
라우트의 경로를 넣고, 두번째 파라미터 에는 해당 라우트에 적용할
미들웨어 함수를 넣는다.
여기서 get 키워드는 해당 라우트에서 사용할 HTTP 메서드 의미.
get 대신 post, put, delete 등을 넣을수 있다.
HTTP 메서드에 대해서도 배워보자.

21.5.2 라우트 파라미터와 쿼리.

이번엔 라우트의 파라미터 와 쿼리 읽는 방법 알아보자.
라우터의 파라미터를 설정할땐 /about/:name 형식으로 콜론(:) 을 사용해 
라우트 경로를 설정.

또 파라미터가 있을수도 있고 없을수도 있다면 /about/:name? 같은 형식으로 
파라미터 이름뒤에 물음표 사용.
이렇게 설정한 파라미터는 함수의 ctx.params 객체에서 조회.

URL 쿼리의 경우, /posts/?id=10 같은 형식으로 요청했다면
해당 값을 ctx.query 에서 조회할수 있다.
쿼리 문자열을 자동으로 객체 형태로 파싱 하므로 별도의 파싱 함수가 필요없다.
( 문자열 형태의 쿼리 문자열을 조회할때는 ctx.querystring 을 사용. )

파라미터와 쿼리를 사용하는 라우트를 다음과 같이 만들어보자.
코드 작성후 /about/react, /posts, /posts?id=10 들어가보기.

파라미터 와 쿼리는 둘다 주소를 통해 특정 값을 받아올때 사용하지만,
용도가 서로 조금씩 다르다. 
정해진 규칙은 따로 없지만, 일반적으로 파라미터는 처리할 작업의 카테고리를
받아오거나, 고유 ID 혹은 이름으로 특정 데이터를 조회할때 사용.

쿼리는 옵션에 관련된 정보 받아옴. 예를 들어 여러 항목을 리스팅 하는
API 라면, 어떤 조건을 만족하는 항목을 보여줄지 또는 어떤 기준으로 정렬할지
정해야할때 쿼리를 사용.

21.5.3 REST API

웹 애플리케이션을 만들려면 데이터베이스에 정보를 입력하고 읽어 와야한다.
그런데 웹 브라우저에서 데이터베이스에 직접 접속하여 데이터를 변경한다면
보안상 문제가 됨. 그래서 REST API 를 만들어 사용.

REST API(서버 측)는 브라우저(클라이언트 측) 과 DB 중간자 역할.

클라이언트가 서버에 자신이 데이터를 조회 생성 삭제 업데이트 하겠다고
요청하면, 서버는 필요한 로직에 따라 데이터베이스에 접근해 작업을 처리함.

REST API 는 요청 종류에 따라 다른 HTTP 메서드를 사용함.

주로 사용하는 메서드 종류

GET : 데이터 조회시 사용.
POST : 데이터를 등록할때 사용. 인증작업 거칠떄도 사용함.
DELETE : 데이터 지울때 사용.
PUT : 데이터를 새 정보로 통째로 교체할때 사용.
PATCH : 데이터의 특정 필드를 수정할때 사용.

메서드의 종류에 따라 get, post, delete, put, patch 를 사용해 
라우터에서 각 메서드의 요청을 처리.
21.5.2 절에서 작성한 라우트에는 router.get 이라고 입력 했는데,
여기서 get 이 바로 HTTP 메서드 GET 이다.
POST 요청은 route.post(...)

REST API 설계할땐 API 주소와 메서드에 따라 어떤 역할을 하는지
쉽게 파악할수 있도록 작성해야함.
블로그 포스트용 REST API 를 예시로 살펴보자.

POST /posts = 포스트 작성 
GET /posts = 포스트 목록 조회 

GET /posts/:id = 특정 포스트 조회 
DELETE /posts/:id = 특정 포스트 삭제 
PATCH /posts/:id = 특정 포스트 업데이트 (구현 방식에 따라 PUT 으로도 가능)

POST /posts/:id/comments = 특정 포스트에 덧글 등록 
GET /posts/:id/comments = 특정 포스트에 덧글 목록 조회 
DELETE /posts/:id/comments/:commentid = 
특정 포스트의 특정 덧글 삭제 

21.5.4 라우트 모듈화

프로젝트를 진행하다 보면 여러 종류의 라우트를 만들게됨.
하지만 각 라우트를 index.js 파일 하나에 모두 작성시,
코드가 너무 길어질뿐 아니라 유지보수 하기도 힘들다.
여기서는 라우터를 여러파일에 분리시켜 작성하고, 이를 불러와 적용하는 
방법을 알아보자.

src 디렉터리에 api 디렉터리 를 생성하고, 그안에 index.js 파일 만들기.

그다음 이 api 라우트를 src/index.js 파일에 불러와
기존 라우터에 /api 경로로 적용. 기존 라우트는 제거.

우리가 만든 api 라우터를 서버의 메인 라우터의 /api 경로로 설정.
따라서 /api/test 경로로 요청하면 조금전 준비한 'test 성공'
문자열이 나타남.
